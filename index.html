<!DOCTYPE html>
<html lang="en" class="">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audit the Odds</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #f8fafc; /* Slate 50 */
            --container-bg: #ffffff; /* White */
            --text-primary: #0f172a; /* Slate 900 */
            --text-secondary: #475569; /* Slate 600 */
            --border-color: #e2e8f0; /* Slate 200 */
            --input-bg: #f1f5f9; /* Slate 100 */
            --header-bg-light: hsla(0, 0%, 100%, 0.7);
            --accent-color: #2563eb; /* Blue 600 */
            --accent-color-light: #eff6ff; /* Blue 50 */
            --accent-text-dark: #1e40af; /* Blue 800 */
            --positive-bg: #f0fdf4; /* Green 50 */
            --positive-text: #15803d; /* Green 700 */
            --positive-border: #bbf7d0; /* Green 300 */
            --negative-bg: #fef2f2; /* Red 50 */
            --negative-text: #b91c1c; /* Red 700 */
            --negative-border: #fecaca; /* Red 300 */
            --highlight-bg: #fefce8; /* Yellow 50 */
        }
        html.dark {
            --bg-color: #020617; /* Slate 950 */
            --container-bg: #0f172a; /* Slate 900 */
            --text-primary: #f1f5f9; /* Slate 100 */
            --text-secondary: #64748b; /* Slate 500 */
            --border-color: #1e293b; /* Slate 800 */
            --input-bg: #1e293b;
            --header-bg-light: hsla(222, 47%, 11%, 0.7);
            --accent-color: #3b82f6; /* Blue 500 */
            --accent-color-light: #1e293b; /* A darker blue-ish slate */
            --accent-text-dark: #93c5fd; /* Blue 300 */
            --positive-bg: #111827; /* Gray 900 */
            --positive-text: #4ade80; /* Green 400 */
            --positive-border: #166534; /* Green 800 */
            --negative-bg: #111827; /* Gray 900 */
            --negative-text: #f87171; /* Red 400 */
            --negative-border: #991b1b; /* Red 800 */
            --highlight-bg: #332c12; /* Dark Yellow */
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-primary);
            transition: background-color 0.3s, color 0.3s;
        }
        header {
            position: sticky;
            top: 1rem;
            z-index: 10;
            background-color: var(--header-bg-light);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            padding: 1.5rem;
            border-radius: 1.25rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            border: 1px solid var(--border-color);
            position: relative; /* Added for canvas positioning */
            overflow: hidden; /* Ensures canvas corners are clipped */
        }
        html.dark header {
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        #theme-toggle { position: absolute; top: 1rem; right: 1rem; }
        #help-btn { position: absolute; top: 1rem; left: 1rem; }
        
        .game-card {
            background-color: var(--container-bg);
            border-radius: 1.25rem;
            padding: 1.5rem;
            box-shadow: 0 6px 15px rgba(0,0,0,0.05);
            border: 1px solid var(--border-color);
            transition: transform 0.2s, box-shadow 0.2s;
            position: relative;
            overflow: hidden;
        }
        .game-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.08);
        }
        html.dark .game-card { box-shadow: 0 6px 15px rgba(0,0,0,0.2); }
        html.dark .game-card:hover { box-shadow: 0 10px 20px rgba(0,0,0,0.3); }
        
        .result-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            margin-top: 0.5rem;
            font-weight: 500;
            border: 1px solid;
            background-color: var(--positive-bg);
        }
        .positive-ev { color: var(--positive-text); border-color: var(--positive-border); }
        .negative-ev { color: var(--negative-text); border-color: var(--negative-border); }
        
        .spinner { animation: rotate 1s linear infinite; }
        @keyframes rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        
        /* Custom Slider & Input Styles */
        input[type=range] { -webkit-appearance: none; background: transparent; cursor: pointer; width: 100%; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-runnable-track { background: var(--input-bg); height: 0.75rem; border-radius: 1rem; border: 1px solid var(--border-color); }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; margin-top: -0.6rem; background-color: var(--accent-color); height: 1.75rem; width: 1.75rem; border-radius: 50%; border: 5px solid var(--container-bg); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        input[type=range]::-moz-range-track { background: var(--input-bg); height: 0.75rem; border-radius: 1rem; border: 1px solid var(--border-color); }
        input[type=range]::-moz-range-thumb { background-color: var(--accent-color); height: 1.75rem; width: 1.75rem; border-radius: 50%; border: 5px solid var(--container-bg); box-shadow: 0 2px 5px rgba(0,0,0,0.2); }
        .prob-input { background-color: var(--input-bg); border: 1px solid var(--border-color); border-radius: 0.375rem; text-align: center; width: 70px; font-weight: 600; padding: 0.25rem; }
        .prob-input:focus { outline: 2px solid var(--accent-color); }

        .utility-btn { background-color: var(--input-bg); border: 1px solid var(--border-color); color: var(--text-secondary); padding: 0.5rem 1rem; border-radius: 9999px; font-weight: 500; transition: all 0.2s; }
        .utility-btn:hover:not(:disabled) { background-color: var(--accent-color-light); border-color: var(--accent-color); color: var(--accent-text-dark); }
        .utility-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Modal Styles */
        #help-modal, #combo-modal, #strategy-combo-modal { transition: opacity 0.3s; }
        #help-modal-content, #combo-modal-content, #strategy-combo-modal-content { transition: transform 0.3s; }

        /* Summary Dashboard */
        .stat-card {
            background-color: var(--container-bg);
            padding: 1rem;
            border-radius: 1rem;
            border: 1px solid var(--border-color);
            box-shadow: 0 4px 6px rgba(0,0,0,0.04);
        }

        /* Combo Modal Highlight */
        .best-combo-highlight {
            background-color: var(--highlight-bg);
        }
    </style>
</head>
<body class="p-4 md:p-6 lg:p-8">
    <div class="max-w-7xl mx-auto"> <!-- Increased max-width for side-by-side layout -->
        <header>
            <canvas id="matrix-canvas" class="absolute top-0 left-0 w-full h-full z-0 opacity-50"></canvas>
            <div class="relative z-10"> <!-- Added wrapper for content -->
                <button id="theme-toggle" class="p-2 rounded-full focus:outline-none" style="color: var(--text-secondary); background-color: var(--bg-color); border: 1px solid var(--border-color);">
                    <svg id="theme-icon-light" class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                    <svg id="theme-icon-dark" class="h-5 w-5 hidden" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg>
                </button>
                <button id="help-btn" class="p-2 rounded-full focus:outline-none" style="color: var(--text-secondary); background-color: var(--bg-color); border: 1px solid var(--border-color);">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-3a1 1 0 00-.867.5 1 1 0 11-1.731-1A3 3 0 0113 8a3.001 3.001 0 01-2 2.83V11a1 1 0 11-2 0v-1a1 1 0 011-1 1 1 0 100-2zm0 8a1 1 0 100-2 1 1 0 000 2z" clip-rule="evenodd" /></svg>
                </button>
                <div class="text-center">
                    <h1 class="text-4xl md:text-5xl font-extrabold mb-2">Audit the Odds <span class="text-lg align-middle font-medium text-secondary">v10.1</span></h1>
                    <p class="text-lg text-secondary">Find value by analyzing live betting lines for today's games.</p>
                </div>
            </div>
        </header>

        <main class="mt-8">
            <!-- Main Action Button -->
            <div id="analyze-section" class="text-center my-12">
                <button id="analyze-today-btn" class="text-xl font-semibold py-4 px-10 rounded-xl transition-transform transform hover:scale-105 shadow-lg hover:shadow-xl focus:outline-none focus:ring-4 focus:ring-offset-2" style="background-color: var(--accent-color); color: white; focus-ring-color: var(--accent-color)">
                    Analyze Today's Games
                </button>
            </div>

            <div id="processingState" class="hidden text-center py-10">
                <svg class="spinner h-8 w-8 mx-auto" style="color: var(--accent-color);" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>
                <p id="processing-text" class="mt-4 text-secondary">Fetching the latest odds... this may take a moment.</p>
            </div>

            <div id="errorState" class="hidden text-center p-4 rounded-lg" style="background-color: var(--negative-bg); color: var(--negative-text);"></div>
            
             <div id="main-content-area" class="grid grid-cols-1 lg:grid-cols-3 lg:gap-8">
                <!-- Bet Slip Area -->
                <div id="bet-slip-area" class="hidden lg:order-last lg:col-span-1 lg:sticky lg:top-32 lg:self-start mt-8 lg:mt-0">
                    <div class="p-4 rounded-xl" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                        <h3 class="text-lg font-semibold mb-3 text-center">My Bet Slip</h3>
                        <div id="bet-slip-list" class="space-y-2 max-h-[60vh] overflow-y-auto">
                            <!-- Selected bets will appear here -->
                        </div>
                        <div id="bet-slip-controls" class="mt-4 flex flex-col gap-2 hidden">
                            <button id="copy-slip-btn" class="text-sm font-semibold py-2 px-4 rounded-lg flex items-center justify-center transition-colors" style="background-color: var(--accent-color); color: white;">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                <span id="copy-slip-btn-text">Copy Slip</span>
                            </button>
                            <button id="combo-analysis-btn" class="utility-btn text-sm w-full" disabled>Round Robin Analysis</button>
                            <button id="clear-slip-btn" class="utility-btn text-sm w-full">Clear Slip</button>
                        </div>
                         <p id="empty-slip-message" class="text-center text-sm text-secondary py-4">Click on a bet to add it to your slip.</p>
                    </div>
                </div>

                <div id="results-area" class="hidden lg:order-first lg:col-span-2">
                    <!-- Summary Dashboard -->
                    <div id="summary-dashboard" class="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 text-center"></div>

                    <!-- Strategy Controls -->
                    <div id="strategy-controls" class="hidden mb-6 p-4 rounded-xl" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                        <h3 class="text-lg font-semibold mb-3 text-center">Parlay Strategy</h3>
                        <div class="flex justify-center space-x-2 mb-4">
                            <button id="select-all-sports" class="utility-btn text-xs">Select All</button>
                            <button id="deselect-all-sports" class="utility-btn text-xs">Deselect All</button>
                        </div>
                        <div id="strategy-options" class="grid grid-cols-2 md:grid-cols-3 gap-2 mb-4"></div>
                        <div class="text-center">
                            <button id="generate-parlay-btn" class="text-base font-semibold py-2 px-6 rounded-lg flex items-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed mx-auto" style="background-color: #16a34a; color: white;" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                <span id="parlay-btn-text">Analyze Parlay Strategy</span>
                            </button>
                        </div>
                    </div>

                    <!-- Filter and Sort Controls -->
                    <div id="filter-controls" class="mb-4 p-4 rounded-xl flex flex-col sm:flex-row flex-wrap items-center justify-between gap-4" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                        <div class="flex items-center space-x-3">
                            <label for="ev-filter-toggle" class="text-sm font-medium whitespace-nowrap">Show +EV Only</label>
                            <label for="ev-filter-toggle" class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" value="" id="ev-filter-toggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-200 rounded-full peer peer-focus:ring-2 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 dark:bg-gray-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-0.5 after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-gray-600 peer-checked:bg-blue-600"></div>
                            </label>
                        </div>
                        <div class="flex items-center space-x-2">
                            <label for="sort-select" class="text-sm font-medium">Sort By:</label>
                            <select id="sort-select" class="text-sm rounded-md p-1" style="background-color: var(--input-bg); border: 1px solid var(--border-color);">
                                <option value="default">Default Order</option>
                                <option value="highest-ev">Highest EV</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-2">
                            <label for="min-odds-filter" class="text-sm font-medium">Min Odds:</label>
                            <input type="number" id="min-odds-filter" placeholder="-200" step="10" class="text-sm rounded-md p-1 w-20" style="background-color: var(--input-bg); border: 1px solid var(--border-color);">
                        </div>
                        <div id="soccer-market-control" class="flex items-center space-x-2 hidden">
                            <label for="soccer-market-select" class="text-sm font-medium">Soccer Bet Type:</label>
                            <select id="soccer-market-select" class="text-sm rounded-md p-1" style="background-color: var(--input-bg); border: 1px solid var(--border-color);">
                                <option value="spread">Asian Line</option>
                                <option value="moneyline">Moneyline</option>
                            </select>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button id="build-momentum-parlay-btn" class="text-sm font-semibold py-2 px-4 rounded-lg flex items-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed" style="background-color: #16a34a; color: white;" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor"><path d="M10.894 2.553a1 1 0 00-1.788 0l-7 14a1 1 0 001.169 1.409l5-1.429A1 1 0 009 15.571V11a1 1 0 112 0v4.571a1 1 0 00.725.962l5 1.428a1 1 0 001.17-1.408l-7-14z" /></svg>
                                <span>Build Momentum Parlay</span>
                            </button>
                            <button id="copy-btn" class="text-sm font-semibold py-2 px-4 rounded-lg flex items-center transition-colors disabled:opacity-50 disabled:cursor-not-allowed" style="background-color: var(--accent-color); color: white;" disabled>
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                                <span id="copy-btn-text">Copy +EV Games</span>
                            </button>
                            <button id="new-analysis-btn" class="utility-btn text-sm py-2 px-4 rounded-lg flex items-center">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M4 10a.75.75 0 01.75-.75h10.5a.75.75 0 010 1.5H4.75A.75.75 0 014 10z" clip-rule="evenodd" /><path fill-rule="evenodd" d="M13.5 4.432a.75.75 0 01.068 1.056l-3.25 4.5a.75.75 0 01-1.139.009l-1.75-2.003a.75.75 0 111.122-1.004l1.18 1.348 2.72-3.778a.75.75 0 011.056-.068z" clip-rule="evenodd" /></svg>
                                New Analysis
                            </button>
                        </div>
                    </div>
                    <div id="game-list-container" class="grid grid-cols-1 gap-6"></div>
                </div>
            </div>
        </main>
    </div>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4 opacity-0">
        <div id="help-modal-content" class="w-full max-w-2xl p-6 md:p-8 rounded-2xl shadow-2xl transform scale-95" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold">How It Works</h3>
                <button id="close-help-modal" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>
            <div class="max-h-[80vh] overflow-y-auto pr-4">
                <div class="text-secondary space-y-4">
                    <p><strong>1. Fetch Data:</strong> The app starts by fetching today's games and the latest odds from The Odds API. This gives us the baseline market price for each bet, including the moneyline and point spread.</p>
                    
                    <p><strong>2. Calculate Implied Momentum:</strong> This is the core of the app's unique analysis. Instead of relying on slow and unstable historical data APIs, it calculates a team's momentum based on the live point spread provided by the market.</p>
                    <ul class="list-disc list-inside space-y-2 pl-4">
                        <li><strong>The Point Spread:</strong> The spread itself is the market's consensus on team strength. A team favored by -10.5 has much stronger "market momentum" than a team favored by -3.5.</li>
                        <li><strong>Momentum Factor:</strong> The app calculates the difference between the home and away spreads to quantify this momentum difference.</li>
                    </ul>

                    <p><strong>3. Adjust Probability:</strong> The initial probability for each team isn't just based on the raw odds; it's adjusted by this market-implied momentum. This creates a small, logical adjustment to the baseline probability, giving you a smarter starting point. This is reflected in the initial position of the slider and the trend arrow (⬆️ or ⬇️).</p>

                    <p><strong>4. Calculate Expected Value (EV):</strong> As you adjust the "True Probability" slider, the app instantly calculates the Expected Value for every available bet using the following formula:</p>
                    <div class="p-3 my-2 rounded-lg text-center" style="background-color: var(--input-bg);">
                        <code class="text-sm font-mono" style="color: var(--text-primary);">EV = (Your Probability × (Decimal Odds - 1)) - (1 - Your Probability)</code>
                    </div>
                    <p>A <strong>Positive EV (+EV)</strong> indicates a bet that is mathematically profitable in the long run, based on your probability estimate. The higher the +EV, the greater the edge you've found.</p>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Round Robin Combo Modal (For Bet Slip) -->
    <div id="combo-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4 opacity-0">
        <div id="combo-modal-content" class="w-full max-w-4xl p-6 md:p-8 rounded-2xl shadow-2xl transform scale-95" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold">Bet Slip - Round Robin Analysis</h3>
                <button id="close-combo-modal" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>
            <div class="space-y-4">
               <p class="text-sm text-secondary">This tool estimates the number of wins you need for different round robin combinations to become profitable based on a flat wager per bet.</p>
               <div class="grid grid-cols-1 md:grid-cols-2 gap-4 p-3 rounded-lg" style="background-color: var(--input-bg);">
                    <div>
                        <label for="wager-per-bet-input" class="block text-sm font-medium">Wager per Bet ($)</label>
                        <input type="number" id="wager-per-bet-input" value="1" min="0.01" step="0.01" class="w-full p-2 rounded-md mt-1" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                    </div>
                    <div>
                        <label for="combo-total-games-input" class="block text-sm font-medium">Total Games</label>
                        <input type="number" id="combo-total-games-input" min="2" class="w-full p-2 rounded-md mt-1" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                    </div>
                    <div class="text-center p-2 rounded-md" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                        <div class="text-sm font-medium text-secondary">Calculated Avg Odds (American)</div>
                        <div id="combo-avg-odds" class="text-xl font-bold">0</div>
                    </div>
                    <div>
                        <label for="combo-override-odds-input" class="block text-sm font-medium">Override Avg Odds (American)</label>
                        <input type="number" id="combo-override-odds-input" placeholder="e.g. -110" step="1" class="w-full p-2 rounded-md mt-1" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                    </div>
                </div>
                <div id="combo-results-container" class="max-h-80 overflow-y-auto pr-2">
                   <!-- Results table will be generated here -->
               </div>
            </div>
        </div>
    </div>
    
    <!-- Round Robin Combo Modal (For Strategy Parlay) -->
    <div id="strategy-combo-modal" class="fixed inset-0 bg-black bg-opacity-70 hidden items-center justify-center z-50 p-4 opacity-0">
        <div id="strategy-combo-modal-content" class="w-full max-w-4xl p-6 md:p-8 rounded-2xl shadow-2xl transform scale-95" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-2xl font-bold">Strategy Parlay - Round Robin Analysis</h3>
                <button id="close-strategy-combo-modal" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" /></svg>
                </button>
            </div>
            <div class="space-y-4">
               <p class="text-sm text-secondary">This tool estimates the number of wins you need for different round robin combinations to become profitable based on a flat wager per bet, using the picks generated by your selected strategy.</p>
               <div class="grid grid-cols-1 md:grid-cols-2 gap-4 p-3 rounded-lg" style="background-color: var(--input-bg);">
                    <div>
                        <label for="strategy-wager-per-bet-input" class="block text-sm font-medium">Wager per Bet ($)</label>
                        <input type="number" id="strategy-wager-per-bet-input" value="1" min="0.01" step="0.01" class="w-full p-2 rounded-md mt-1" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                    </div>
                     <div>
                        <label for="strategy-combo-total-games-input" class="block text-sm font-medium">Total Games</label>
                        <input type="number" id="strategy-combo-total-games-input" min="2" class="w-full p-2 rounded-md mt-1" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                    </div>
                    <div class="text-center p-2 rounded-md" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                        <div class="text-sm font-medium text-secondary">Calculated Avg Odds (American)</div>
                        <div id="strategy-combo-avg-odds" class="text-xl font-bold">0</div>
                    </div>
                    <div>
                        <label for="strategy-override-odds-input" class="block text-sm font-medium">Override Avg Odds (American)</label>
                        <input type="number" id="strategy-override-odds-input" placeholder="e.g. -110" step="1" class="w-full p-2 rounded-md mt-1" style="background-color: var(--container-bg); border: 1px solid var(--border-color);">
                    </div>
                </div>
                <div id="strategy-combo-results-container" class="max-h-80 overflow-y-auto pr-2">
                   <!-- Results table will be generated here -->
               </div>
               <div class="mt-6 flex justify-end space-x-3">
                    <button id="copy-strategy-parlay-btn" class="text-sm font-semibold py-2 px-4 rounded-lg flex items-center transition-colors" style="background-color: var(--accent-color); color: white;">
                       <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-2" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path></svg>
                       <span id="copy-strategy-parlay-btn-text">Copy Parlay & Close</span>
                   </button>
               </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            /**
             * Generates a momentum-adjusted probability based on the point spread.
             * A more favorable spread implies stronger "market momentum".
             * @param {number} baseProbability - The initial probability from the moneyline odds.
             * @param {object} game - The game data object.
             * @returns {object} An object containing the adjusted probability and a status.
             */
            function getMomentumAdjustedProbability(baseProbability, game) {
                if (game.spread_away == null || game.spread_home == null) {
                    return { prob: baseProbability, status: 'no_data' };
                }

                // Calculate momentum based on the difference in point spreads.
                // A larger spread difference implies stronger momentum for the favorite.
                // The factor is halved to get the effective spread from the midpoint (e.g., +/- 7.5 -> 7.5)
                const momentumFactor = (game.spread_home - game.spread_away) / 2;
                
                // Convert the point spread momentum into a small probability adjustment.
                // A 10-point spread favorite gets a 5% probability boost relative to the baseline.
                const probabilityAdjustment = momentumFactor * 0.005;

                let adjustedProb = baseProbability + probabilityAdjustment;

                // Ensure the probability stays within the valid range [0.01, 0.99].
                adjustedProb = Math.max(0.01, Math.min(0.99, adjustedProb));

                return { prob: adjustedProb, status: 'ok' };
            }


            // --- DOM ELEMENTS ---
            const gameListContainer = document.getElementById('game-list-container');
            const processingState = document.getElementById('processingState');
            const processingText = document.getElementById('processing-text');
            const errorState = document.getElementById('errorState');
            const themeToggle = document.getElementById('theme-toggle');
            const themeIconLight = document.getElementById('theme-icon-light');
            const themeIconDark = document.getElementById('theme-icon-dark');
            const resultsArea = document.getElementById('results-area');
            const filterControls = document.getElementById('filter-controls');
            const evFilterToggle = document.getElementById('ev-filter-toggle');
            const sortSelect = document.getElementById('sort-select');
            const soccerMarketControl = document.getElementById('soccer-market-control');
            const soccerMarketSelect = document.getElementById('soccer-market-select');
            const copyBtn = document.getElementById('copy-btn');
            const copyBtnText = document.getElementById('copy-btn-text');
            const buildMomentumParlayBtn = document.getElementById('build-momentum-parlay-btn');
            const analyzeSection = document.getElementById('analyze-section');
            const analyzeTodayBtn = document.getElementById('analyze-today-btn');
            const strategyControls = document.getElementById('strategy-controls');
            const strategyOptionsContainer = document.getElementById('strategy-options');
            const generateParlayBtn = document.getElementById('generate-parlay-btn');
            const parlayBtnText = document.getElementById('parlay-btn-text');
            const newAnalysisBtn = document.getElementById('new-analysis-btn');
            const helpBtn = document.getElementById('help-btn');
            const helpModal = document.getElementById('help-modal');
            const helpModalContent = document.getElementById('help-modal-content');
            const closeHelpModalBtn = document.getElementById('close-help-modal');
            const summaryDashboard = document.getElementById('summary-dashboard');
            const minOddsFilter = document.getElementById('min-odds-filter');
            
            const betSlipArea = document.getElementById('bet-slip-area');
            const betSlipList = document.getElementById('bet-slip-list');
            const betSlipControls = document.getElementById('bet-slip-controls');
            const emptySlipMessage = document.getElementById('empty-slip-message');
            const copySlipBtn = document.getElementById('copy-slip-btn');
            const copySlipBtnText = document.getElementById('copy-slip-btn-text');
            const clearSlipBtn = document.getElementById('clear-slip-btn');
            
            // Bet Slip Combo Modal Elements
            const comboAnalysisBtn = document.getElementById('combo-analysis-btn');
            const comboModal = document.getElementById('combo-modal');
            const comboModalContent = document.getElementById('combo-modal-content');
            const closeComboModalBtn = document.getElementById('close-combo-modal');
            const wagerPerBetInput = document.getElementById('wager-per-bet-input');
            const comboTotalGamesInput = document.getElementById('combo-total-games-input');
            const comboAvgOdds = document.getElementById('combo-avg-odds');
            const comboResultsContainer = document.getElementById('combo-results-container');
            const comboOverrideOddsInput = document.getElementById('combo-override-odds-input');

            // Strategy Combo Modal Elements
            const strategyComboModal = document.getElementById('strategy-combo-modal');
            const strategyComboModalContent = document.getElementById('strategy-combo-modal-content');
            const closeStrategyComboModalBtn = document.getElementById('close-strategy-combo-modal');
            const strategyWagerPerBetInput = document.getElementById('strategy-wager-per-bet-input');
            const strategyComboTotalGamesInput = document.getElementById('strategy-combo-total-games-input');
            const strategyComboAvgOdds = document.getElementById('strategy-combo-avg-odds');
            const strategyComboResultsContainer = document.getElementById('strategy-combo-results-container');
            const copyStrategyParlayBtn = document.getElementById('copy-strategy-parlay-btn');
            const copyStrategyParlayBtnText = document.getElementById('copy-strategy-parlay-btn-text');
            const strategyOverrideOddsInput = document.getElementById('strategy-override-odds-input');
            
            let currentStrategyBets = [];
            let ALL_SPORTS_DATA = [];
            let gameCardElements = [];
            let betSlip = [];
            let slipContext = { type: 'Custom Bet Slip', settings: '' };

            // --- Hardcoded API Keys ---
            // WARNING: Exposing API keys on the client-side is a security risk.
            // In a production environment, use a backend proxy to protect your keys.
            const oddsApiKey = 'cc51a757d14174fd8061956b288df39e';
			
            // --- THEME SWITCHER ---
            const applyTheme = (theme) => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                    themeIconLight.classList.add('hidden');
                    themeIconDark.classList.remove('hidden');
                } else {
                    document.documentElement.classList.remove('dark');
                    themeIconLight.classList.remove('hidden');
                    themeIconDark.classList.add('hidden');
                }
            };
            themeToggle.addEventListener('click', () => {
                const newTheme = document.documentElement.classList.contains('dark') ? 'light' : 'dark';
                localStorage.setItem('theme', newTheme);
                applyTheme(newTheme);
            });
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            applyTheme(savedTheme || (prefersDark ? 'dark' : 'light'));

            // --- Matrix Effect ---
            const canvas = document.getElementById('matrix-canvas');
            const ctx = canvas.getContext('2d');
            const headerElement = canvas.closest('header');

            let animationFrameId;

            function setupMatrix() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }

                const dpr = window.devicePixelRatio || 1;
                canvas.width = headerElement.offsetWidth * dpr;
                canvas.height = headerElement.offsetHeight * dpr;
                ctx.scale(dpr, dpr);

                const characters = '0123456789$+-*/=';
                const fontSize = 14;
                const columns = Math.floor(headerElement.offsetWidth / fontSize);
                const drops = [];

                for (let x = 0; x < columns; x++) {
                    drops[x] = 1;
                }

                function draw() {
                    ctx.fillStyle = document.documentElement.classList.contains('dark') ? 'rgba(15, 23, 42, 0.15)' : 'rgba(255, 255, 255, 0.15)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.fillStyle = document.documentElement.classList.contains('dark') ? '#3b82f6' : '#2563eb';
                    ctx.font = `${fontSize}px Inter, monospace`;

                    for (let i = 0; i < drops.length; i++) {
                        const text = characters.charAt(Math.floor(Math.random() * characters.length));
                        ctx.fillText(text, i * fontSize, drops[i] * fontSize);

                        if (drops[i] * fontSize > headerElement.offsetHeight && Math.random() > 0.975) {
                            drops[i] = 0;
                        }
                        drops[i]++;
                    }
                    animationFrameId = requestAnimationFrame(draw);
                }
                draw();
            }
            
            setTimeout(setupMatrix, 100); 
            new ResizeObserver(setupMatrix).observe(headerElement);
            themeToggle.addEventListener('click', () => {
                 setTimeout(setupMatrix, 100);
            });


            // --- TEAM DATA ---
            const LOGO_BASE_URL = 'https://a.espncdn.com/i/teamlogos';
            const TEAM_INFO = {
                // NFL
                'Arizona Cardinals': { id: '134931', logoId: 'nfl/500/ari.png' },
                'Atlanta Falcons': { id: '134919', logoId: 'nfl/500/atl.png' },
                'Baltimore Ravens': { id: '134925', logoId: 'nfl/500/bal.png' },
                'Buffalo Bills': { id: '134910', logoId: 'nfl/500/buf.png' },
                'Carolina Panthers': { id: '134932', logoId: 'nfl/500/car.png' },
                'Chicago Bears': { id: '134914', logoId: 'nfl/500/chi.png' },
                'Cincinnati Bengals': { id: '134916', logoId: 'nfl/500/cin.png' },
                'Cleveland Browns': { id: '134915', logoId: 'nfl/500/cle.png' },
                'Dallas Cowboys': { id: '134923', logoId: 'nfl/500/dal.png' },
                'Denver Broncos': { id: '134926', logoId: 'nfl/500/den.png' },
                'Detroit Lions': { id: '134913', logoId: 'nfl/500/det.png' },
                'Green Bay Packers': { id: '134912', logoId: 'nfl/500/gb.png' },
                'Houston Texans': { id: '134938', logoId: 'nfl/500/hou.png' },
                'Indianapolis Colts': { id: '134918', logoId: 'nfl/500/ind.png' },
                'Jacksonville Jaguars': { id: '134933', logoId: 'nfl/500/jax.png' },
                'Kansas City Chiefs': { id: '134921', logoId: 'nfl/500/kc.png' },
                'Las Vegas Raiders': { id: '134922', logoId: 'nfl/500/lv.png' },
                'Los Angeles Chargers': { id: '134928', logoId: 'nfl/500/lac.png' },
                'Los Angeles Rams': { id: '134930', logoId: 'nfl/500/lar.png' },
                'Miami Dolphins': { id: '134909', logoId: 'nfl/500/mia.png' },
                'Minnesota Vikings': { id: '134911', logoId: 'nfl/500/min.png' },
                'New England Patriots': { id: '134908', logoId: 'nfl/500/ne.png' },
                'New Orleans Saints': { id: '134927', logoId: 'nfl/500/no.png' },
                'New York Giants': { id: '134924', logoId: 'nfl/500/nyg.png' },
                'New York Jets': { id: '134907', logoId: 'nfl/500/nyj.png' },
                'Philadelphia Eagles': { id: '134920', logoId: 'nfl/500/phi.png' },
                'Pittsburgh Steelers': { id: '134917', logoId: 'nfl/500/pit.png' },
                'San Francisco 49ers': { id: '134929', logoId: 'nfl/500/sf.png' },
                'Seattle Seahawks': { id: '134934', logoId: 'nfl/500/sea.png' },
                'Tampa Bay Buccaneers': { id: '134935', logoId: 'nfl/500/tb.png' },
                'Tennessee Titans': { id: '134936', logoId: 'nfl/500/ten.png' },
                'Washington Commanders': { id: '134937', logoId: 'nfl/500/wsh.png' },
                // NBA
                'Atlanta Hawks': { id: '134873', logoId: 'nba/500/atl.png' },
                'Boston Celtics': { id: '134860', logoId: 'nba/500/bos.png' },
                'Brooklyn Nets': { id: '134861', logoId: 'nba/500/bkn.png' },
                'Charlotte Hornets': { id: '134874', logoId: 'nba/500/cha.png' },
                'Chicago Bulls': { id: '134868', logoId: 'nba/500/chi.png' },
                'Cleveland Cavaliers': { id: '134867', logoId: 'nba/500/cle.png' },
                'Dallas Mavericks': { id: '134888', logoId: 'nba/500/dal.png' },
                'Denver Nuggets': { id: '134881', logoId: 'nba/500/den.png' },
                'Detroit Pistons': { id: '134866', logoId: 'nba/500/det.png' },
                'Golden State Warriors': { id: '134878', logoId: 'nba/500/gsw.png' },
                'Houston Rockets': { id: '134887', logoId: 'nba/500/hou.png' },
                'Indiana Pacers': { id: '134865', logoId: 'nba/500/ind.png' },
                'Los Angeles Clippers': { id: '134877', logoId: 'nba/500/lac.png' },
                'Los Angeles Lakers': { id: '134876', logoId: 'nba/500/lal.png' },
                'Memphis Grizzlies': { id: '134889', logoId: 'nba/500/mem.png' },
                'Miami Heat': { id: '134875', logoId: 'nba/500/mia.png' },
                'Milwaukee Bucks': { id: '134864', logoId: 'nba/500/mil.png' },
                'Minnesota Timberwolves': { id: '134880', logoId: 'nba/500/min.png' },
                'New Orleans Pelicans': { id: '134890', logoId: 'nba/500/no.png' },
                'New York Knicks': { id: '134862', logoId: 'nba/500/nyk.png' },
                'Oklahoma City Thunder': { id: '134883', logoId: 'nba/500/okc.png' },
                'Orlando Magic': { id: '134872', logoId: 'nba/500/orl.png' },
                'Philadelphia 76ers': { id: '134863', logoId: 'nba/500/phi.png' },
                'Phoenix Suns': { id: '134879', logoId: 'nba/500/phx.png' },
                'Portland Trail Blazers': { id: '134882', logoId: 'nba/500/por.png' },
                'Sacramento Kings': { id: '134884', logoId: 'nba/500/sac.png' },
                'San Antonio Spurs': { id: '134886', logoId: 'nba/500/sa.png' },
                'Toronto Raptors': { id: '134869', logoId: 'nba/500/tor.png' },
                'Utah Jazz': { id: '134885', logoId: 'nba/500/utah.png' },
                'Washington Wizards': { id: '134871', logoId: 'nba/500/wsh.png' },
                // MLB
                'Arizona Diamondbacks': { id: '134891', logoId: 'mlb/500/ari.png' },
                'Atlanta Braves': { id: '134879', logoId: 'mlb/500/atl.png' },
                'Baltimore Orioles': { id: '134897', logoId: 'mlb/500/bal.png' },
                'Boston Red Sox': { id: '134884', logoId: 'mlb/500/bos.png' },
                'Chicago Cubs': { id: '134882', logoId: 'mlb/500/chc.png' },
                'Chicago White Sox': { id: '134902', logoId: 'mlb/500/chw.png' },
                'Cincinnati Reds': { id: '134883', logoId: 'mlb/500/cin.png' },
                'Cleveland Guardians': { id: '134903', logoId: 'mlb/500/cle.png' },
                'Colorado Rockies': { id: '134890', logoId: 'mlb/500/col.png' },
                'Detroit Tigers': { id: '134904', logoId: 'mlb/500/det.png' },
                'Houston Astros': { id: '134886', logoId: 'mlb/500/hou.png' },
                'Kansas City Royals': { id: '134905', logoId: 'mlb/500/kc.png' },
                'Los Angeles Angels': { id: '134901', logoId: 'mlb/500/ana.png' },
                'Los Angeles Dodgers': { id: '134880', logoId: 'mlb/500/lad.png' },
                'Miami Marlins': { id: '134878', logoId: 'mlb/500/mia.png' },
                'Milwaukee Brewers': { id: '134885', logoId: 'mlb/500/mil.png' },
                'Minnesota Twins': { id: '134906', logoId: 'mlb/500/min.png' },
                'New York Mets': { id: '134877', logoId: 'mlb/500/nym.png' },
                'New York Yankees': { id: '134899', logoId: 'mlb/500/nyy.png' },
                'Oakland Athletics': { id: '134900', logoId: 'mlb/500/oak.png' },
                'Philadelphia Phillies': { id: '134876', logoId: 'mlb/500/phi.png' },
                'Pittsburgh Pirates': { id: '134881', logoId: 'mlb/500/pit.png' },
                'San Diego Padres': { id: '134892', logoId: 'mlb/500/sd.png' },
                'San Francisco Giants': { id: '134893', logoId: 'mlb/500/sf.png' },
                'Seattle Mariners': { id: '134896', logoId: 'mlb/500/sea.png' },
                'St. Louis Cardinals': { id: '134888', logoId: 'mlb/500/stl.png' },
                'Tampa Bay Rays': { id: '134898', logoId: 'mlb/500/tb.png' },
                'Texas Rangers': { id: '134895', logoId: 'mlb/500/tex.png' },
                'Toronto Blue Jays': { id: '134894', logoId: 'mlb/500/tor.png' },
                'Washington Nationals': { id: '134875', logoId: 'mlb/500/wsh.png' },
                // CFL
                'BC Lions': { id: '135246', logoId: 'cfl/500/bc.png' },
                'Calgary Stampeders': { id: '135248', logoId: 'cfl/500/cal.png' },
                'Edmonton Elks': { id: '135247', logoId: 'cfl/500/edm.png' },
                'Saskatchewan Roughriders': { id: '135249', logoId: 'cfl/500/sask.png' },
                'Winnipeg Blue Bombers': { id: '135250', logoId: 'cfl/500/wpg.png' },
                'Hamilton Tiger-Cats': { id: '135251', logoId: 'cfl/500/ham.png' },
                'Toronto Argonauts': { id: '135252', logoId: 'cfl/500/tor.png' },
                'Ottawa Redblacks': { id: '137459', logoId: 'cfl/500/ott.png' },
                'Montreal Alouettes': { id: '135253', logoId: 'cfl/500/mtl.png' },
                // NCAAF
                'Alabama Crimson Tide': { id: '134803', logoId: 'ncf/500/333.png' },
                'Georgia Bulldogs': { id: '134804', logoId: 'ncf/500/61.png' },
                'Ohio State Buckeyes': { id: '134798', logoId: 'ncf/500/194.png' },
                'Michigan Wolverines': { id: '134805', logoId: 'ncf/500/130.png' },
                'Texas Longhorns': { id: '134823', logoId: 'ncf/500/251.png' },
                'USC Trojans': { id: '134840', logoId: 'ncf/500/30.png' },
                'Notre Dame Fighting Irish': { id: '134802', logoId: 'ncf/500/87.png' },
                'Clemson Tigers': { id: '134812', logoId: 'ncf/500/228.png' },
                'LSU Tigers': { id: '134807', logoId: 'ncf/500/99.png' },
                'Penn State Nittany Lions': { id: '134799', logoId: 'ncf/500/213.png' },
            };

            function getTeamInfo(teamName) {
                if (!teamName) return { name: 'Unknown', logo: '', id: null };
                
                // Use a more robust matching by checking if the API team name includes a key from our list.
                const teamKey = Object.keys(TEAM_INFO).find(key => teamName.includes(key));

                if (teamKey && TEAM_INFO[teamKey]) {
                    const info = TEAM_INFO[teamKey];
                    const logo = info.logoId ? `${LOGO_BASE_URL}/${info.logoId}` : `https://placehold.co/96x96/e2e8f0/64748b?text=${teamName.substring(0,2)}`;
                    return {
                        name: teamName, // Return original name for consistency
                        logo: logo,
                        id: info.id
                    };
                }
                // Fallback for any teams not in our list
                return { name: teamName, logo: `https://placehold.co/96x96/e2e8f0/64748b?text=${teamName.substring(0,2)}`, id: null };
            }

            const SPORT_MAP = { 'NFL': 'Football', 'CFL': 'Football', 'NCAAF': 'Football', 'MLB': 'Baseball', 'NBA': 'Basketball', 'WNBA': 'Basketball', 'SOCCER': 'Soccer', 'NHL': 'Hockey', 'NCAAB': 'Basketball' };
            const SPORT_KEY_MAP = { 'NFL': 'americanfootball_nfl', 'CFL': 'americanfootball_cfl', 'NCAAF': 'americanfootball_ncaaf', 'MLB': 'baseball_mlb', 'NBA': 'basketball_nba', 'WNBA': 'basketball_wnba', 'NHL': 'icehockey_nhl', 'NCAAB': 'basketball_ncaab', 'SOCCER': 'soccer_usa_mls' }; 

            function getGameSport(game) {
                 if (game.sport && game.sport.toUpperCase() in SPORT_MAP) { return SPORT_MAP[game.sport.toUpperCase()]; }
                return 'Unknown';
            }
             function getSportKey(game) {
                const sportName = getGameSport(game).toUpperCase();
                if (sportName === 'SOCCER') return 'soccer_epl'; // Defaulting to EPL for demo
                return SPORT_KEY_MAP[sportName] || null;
            }


            // --- CORE LOGIC & CALCULATIONS ---
            const calculateEV = (winProb, decimalOdds) => (winProb * (decimalOdds - 1)) - (1 - winProb);
            
            function americanToDecimal(americanOdds) {
                if (isNaN(americanOdds) || americanOdds === 0) return NaN;
                if (americanOdds >= 100) {
                    return (americanOdds / 100) + 1;
                } else if (americanOdds <= -100) {
                    return (100 / Math.abs(americanOdds)) + 1;
                }
                return NaN; // Invalid American odds (e.g., between -99 and 99)
            }

            function decimalToAmerican(decimalOdds) {
                if (isNaN(decimalOdds) || decimalOdds <= 1) return 'N/A';
                if (decimalOdds >= 2.0) {
                    return `+${((decimalOdds - 1) * 100).toFixed(0)}`;
                } else {
                    return `${(-100 / (decimalOdds - 1)).toFixed(0)}`;
                }
            }

            function combinations(n, k) {
                if (k < 0 || k > n) {
                    return 0;
                }
                if (n - k < k) {
                    k = n - k;
                }
                let res = 1;
                for (let i = 1; i <= k; i++) {
                    res = res * (n - i + 1) / i;
                }
                return Math.round(res);
            }
            
             async function fetchAndAnalyzeGames() {
                if (!oddsApiKey) {
                    showError("The Odds API key is missing. Please add it to the code.");
                    return;
                }

                analyzeSection.classList.add('hidden');
                processingState.classList.remove('hidden');
                errorState.classList.add('hidden');
                gameListContainer.innerHTML = '';
                resultsArea.classList.add('hidden');
                
                try {
                    // Step 1: Fetch all active sports and current odds
                    processingText.textContent = 'Finding in-season sports & fetching odds...';
                    const sportsApiUrl = `https://api.the-odds-api.com/v4/sports/?apiKey=${oddsApiKey}`;
                    const sportsResponse = await fetch(sportsApiUrl);
                    if (!sportsResponse.ok) throw new Error('Failed to fetch sports list.');
                    const availableSports = await sportsResponse.json();

                    const desiredSportTitles = ['NFL', 'MLB', 'NBA', 'NHL', 'WNBA', 'CFL', 'NCAAF', 'NCAAB', 'Premier League'];
                    // FIX: Instead of relying on the API's potentially slow-to-update `active` flag, 
                    // we will now attempt to fetch games for all desired sports. If no games are scheduled,
                    // the API will simply return an empty list for that sport, which is handled gracefully.
                    const activeSports = availableSports
                        .filter(sport => desiredSportTitles.includes(sport.title));

                    if (activeSports.length === 0) {
                        showError("No desired sports could be found in the API's list.");
                        return;
                    }

                    const now = new Date();
                    const endOfDay = new Date();
                    endOfDay.setHours(23, 59, 59, 999); // Set to the end of the current calendar day.

                    // This filters for games starting between now and the end of today.
                    const commenceTimeFrom = now.toISOString().slice(0, 19) + 'Z';
                    const commenceTimeTo = endOfDay.toISOString().slice(0, 19) + 'Z';


                    const oddsPromises = activeSports.map(sport => {
                        const apiUrl = `https://api.the-odds-api.com/v4/sports/${sport.key}/odds?apiKey=${oddsApiKey}&regions=us&markets=h2h,spreads,totals&oddsFormat=decimal&commenceTimeFrom=${commenceTimeFrom}&commenceTimeTo=${commenceTimeTo}`;
                        return fetch(apiUrl).then(res => res.json());
                    });

                    const allGamesNested = await Promise.all(oddsPromises);
                    const allGames = allGamesNested.flat();

                    if (allGames.length === 0) {
                        showError("No upcoming games found for active sports in the next 24 hours.");
                        return;
                    }

                    ALL_SPORTS_DATA = allGames.map(transformApiData).filter(g => g !== null);
                    
                    if (ALL_SPORTS_DATA.length > 0) {
                        displayGames(ALL_SPORTS_DATA);
                    } else {
                        showError("Could not process the odds data.");
                    }

                } catch (err) {
                    console.error("Failed during analysis:", err);
                    showError(`An error occurred: ${err.message}.`);
                } finally {
                    processingState.classList.add('hidden');
                }
            }
            
            function transformApiData(apiGame) {
                const bookmaker = apiGame.bookmakers?.[0];
                if (!bookmaker) return null;

                const moneylineMarket = bookmaker.markets.find(m => m.key === 'h2h');
                const spreadMarket = bookmaker.markets.find(m => m.key === 'spreads');
                const totalMarket = bookmaker.markets.find(m => m.key === 'totals');

                const moneylineAwayOutcome = moneylineMarket?.outcomes.find(o => o.name === apiGame.away_team);
                const moneylineHomeOutcome = moneylineMarket?.outcomes.find(o => o.name === apiGame.home_team);
                
                const spreadAwayOutcome = spreadMarket?.outcomes.find(o => o.name === apiGame.away_team);
                const spreadHomeOutcome = spreadMarket?.outcomes.find(o => o.name === apiGame.home_team);

                const totalOverOutcome = totalMarket?.outcomes.find(o => o.name === 'Over');
                const totalUnderOutcome = totalMarket?.outcomes.find(o => o.name === 'Under');

                let sport = 'Unknown';
                 if (apiGame.sport_key.includes('nfl')) sport = 'NFL';
                else if (apiGame.sport_key.includes('cfl')) sport = 'CFL';
                else if (apiGame.sport_key.includes('ncaaf')) sport = 'NCAAF';
                else if (apiGame.sport_key.includes('ncaab')) sport = 'NCAAB';
                else if (apiGame.sport_key.includes('mlb')) sport = 'MLB';
                else if (apiGame.sport_key.includes('nba')) sport = 'NBA';
                else if (apiGame.sport_key.includes('wnba')) sport = 'WNBA';
                else if (apiGame.sport_key.includes('soccer')) sport = 'SOCCER';
                else if (apiGame.sport_key.includes('nhl')) sport = 'NHL';

                return {
                    id: apiGame.id,
                    sport: sport,
                    sport_key: apiGame.sport_key,
                    away_team: apiGame.away_team,
                    home_team: apiGame.home_team,
                    moneyline_away: moneylineAwayOutcome?.price || null,
                    moneyline_home: moneylineHomeOutcome?.price || null,
                    spread_away: spreadAwayOutcome?.point || null,
                    spread_away_odds: spreadAwayOutcome?.price || null,
                    spread_home: spreadHomeOutcome?.point || null,
                    spread_home_odds: spreadHomeOutcome?.price || null,
                    total_over: totalOverOutcome?.point || null,
                    total_over_odds: totalOverOutcome?.price || null,
                    total_under: totalUnderOutcome?.point || null,
                    total_under_odds: totalUnderOutcome?.price || null,
                };
            }

            function createGameCard(game, index) {
                const gameId = `game-${index}`;
                const card = document.createElement('div');
                card.className = 'game-card';
                card.id = gameId;
                card.dataset.gameIndex = index;
                const gameSport = getGameSport(game);
                card.dataset.sport = gameSport;

                const awayTeamInfo = getTeamInfo(game.away_team);
                const homeTeamInfo = getTeamInfo(game.home_team);

                let awayOddsDisplay, homeOddsDisplay;
                const soccerMarketType = soccerMarketSelect.value;
                
                if (gameSport === 'Soccer' && soccerMarketType === 'spread' && game.spread_away != null && game.spread_home != null) {
                    awayOddsDisplay = `${game.spread_away > 0 ? '+' : ''}${game.spread_away}`;
                    homeOddsDisplay = `${game.spread_home > 0 ? '+' : ''}${game.spread_home}`;
                } else {
                    const awayAmericanOdds = game.moneyline_away ? (game.moneyline_away >= 2 ? (game.moneyline_away - 1) * 100 : -100 / (game.moneyline_away - 1)) : null;
                    const homeAmericanOdds = game.moneyline_home ? (game.moneyline_home >= 2 ? (game.moneyline_home - 1) * 100 : -100 / (game.moneyline_home - 1)) : null;
                    awayOddsDisplay = awayAmericanOdds ? `${awayAmericanOdds > 0 ? '+' : ''}${awayAmericanOdds.toFixed(0)}` : 'N/A';
                    homeOddsDisplay = homeAmericanOdds ? `${homeAmericanOdds > 0 ? '+' : ''}${homeAmericanOdds.toFixed(0)}` : 'N/A';
                }
                
                const impliedAway = game.moneyline_away ? 1 / game.moneyline_away : 0.5;
                const impliedHome = game.moneyline_home ? 1 / game.moneyline_home : 0.5;
                const totalImplied = impliedAway + impliedHome;
                const normalizedAwayProb = totalImplied > 0 ? impliedAway / totalImplied : 0.5;

                const momentumResult = getMomentumAdjustedProbability(normalizedAwayProb, game);
                const momentumAdjustedProb = momentumResult.prob;
                const initialSliderValue = Math.round(momentumAdjustedProb * 1000);
                
                let momentumIndicatorHtml = '';

                if (momentumResult.status === 'no_data') {
                    momentumIndicatorHtml = `
                        <span class="ml-2 flex items-center text-xs font-bold" style="color: var(--text-secondary);" title="Point spread data not available for momentum calculation.">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM8.707 7.293a1 1 0 00-1.414 1.414L8.586 10l-1.293 1.293a1 1 0 101.414 1.414L10 11.414l1.293 1.293a1 1 0 001.414-1.414L11.414 10l1.293-1.293a1 1 0 00-1.414-1.414L10 8.586 8.707 7.293z" clip-rule="evenodd" /></svg>
                            <span>N/A</span>
                        </span>
                    `;
                } else {
                    const probabilityShift = (momentumAdjustedProb - normalizedAwayProb) * 100;
                    const shiftColor = probabilityShift > 0.1 ? 'var(--positive-text)' : probabilityShift < -0.1 ? 'var(--negative-text)' : 'var(--text-secondary)';
                    const arrowSvg = probabilityShift > 0.1 
                        ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M14.707 12.707a1 1 0 01-1.414 0L10 9.414l-3.293 3.293a1 1 0 01-1.414-1.414l4-4a1 1 0 011.414 0l4 4a1 1 0 010 1.414z" clip-rule="evenodd" /></svg>`
                        : probabilityShift < -0.1
                        ? `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" /></svg>`
                        : `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mr-1" viewBox="0 0 20 20" fill="currentColor"><path d="M10 3a1 1 0 011 1v12a1 1 0 11-2 0V4a1 1 0 011-1z" /><path d="M3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" /></svg>`;
                    
                    momentumIndicatorHtml = `
                        <span class="ml-2 flex items-center text-xs font-bold" style="color: ${shiftColor};" title="Momentum adjustment based on the market point spread.">
                            ${arrowSvg}
                            <span>${probabilityShift.toFixed(1)}%</span>
                        </span>
                    `;
                }

                card.innerHTML = `
                    <div class="relative"><span class="absolute -top-6 -left-6 text-xs font-bold uppercase px-3 py-1 rounded-br-lg rounded-tl-xl" style="background-color: var(--accent-color-light); color: var(--accent-text-dark);">${gameSport}</span></div>
                    <div class="grid md:grid-cols-2 gap-x-6 gap-y-8 items-start pt-4">
                        <!-- Team Matchup -->
                        <div class="flex items-center justify-around text-center">
                            <div class="flex flex-col items-center space-y-1 w-2/5">
                                <img src="${awayTeamInfo.logo}" alt="${awayTeamInfo.name}" class="h-16 w-16 md:h-20 md:w-20 object-contain mb-1" onerror="this.src='https://placehold.co/96x96/e2e8f0/64748b?text=${awayTeamInfo.name.substring(0,1)}'; this.onerror=null;">
                                <span class="font-bold text-sm md:text-base leading-tight">${awayTeamInfo.name}</span>
                                <span class="font-semibold text-lg" style="color: var(--accent-color);">${awayOddsDisplay}</span>
                            </div>
                            <div class="font-bold text-xl text-secondary pb-10">VS</div>
                            <div class="flex flex-col items-center space-y-1 w-2/5">
                                <img src="${homeTeamInfo.logo}" alt="${homeTeamInfo.name}" class="h-16 w-16 md:h-20 md:w-20 object-contain mb-1" onerror="this.src='https://placehold.co/96x96/e2e8f0/64748b?text=${homeTeamInfo.name.substring(0,1)}'; this.onerror=null;">
                                <span class="font-bold text-sm md:text-base leading-tight">${homeTeamInfo.name}</span>
                                <span class="font-semibold text-lg" style="color: var(--accent-color);">${homeOddsDisplay}</span>
                            </div>
                        </div>
                        
                        <!-- Controls & Results -->
                        <div class="border-t-2 md:border-t-0 md:border-l-2 pt-6 md:pt-0 md:pl-6" style="border-color: var(--border-color);">
                            <div class="mb-3">
                                <div class="flex items-center justify-center mb-2">
                                    <label class="block text-sm font-medium text-center">Your Estimated True Probability</label>
                                    ${momentumIndicatorHtml}
                                </div>
                                <div class="flex items-center justify-between text-center font-bold text-lg mb-2">
                                    <input type="number" step="0.1" min="0" max="100" id="${gameId}-away-prob-input" value="${(momentumAdjustedProb * 100).toFixed(1)}" class="prob-input">
                                    <input type="number" step="0.1" min="0" max="100" id="${gameId}-home-prob-input" value="${((1 - momentumAdjustedProb) * 100).toFixed(1)}" class="prob-input">
                                </div>
                                <div class="flex items-center space-x-2"><input type="range" min="0" max="1000" value="${initialSliderValue}" class="flex-1 prob-slider" data-game-index="${index}" data-initial-value="${initialSliderValue}"></div>
                            </div>
                            <div class="mt-4 flex justify-center items-center space-x-2">
                                <button class="utility-btn fifty-fifty-btn text-xs" data-game-index="${index}">50/50</button>
                                <button class="utility-btn reset-prob-btn text-xs" data-game-index="${index}">Reset</button>
                            </div>
                            <div id="${gameId}-results" class="mt-4 space-y-3"></div>
                        </div>
                    </div>
                `;
                return card;
            }

            // --- UI & STATE MANAGEMENT ---
            function showError(message, isPartial = false) {
                errorState.innerHTML = message; // Use innerHTML to render links
                errorState.classList.remove('hidden');
                if (!isPartial) {
                    processingState.classList.add('hidden');
                    analyzeSection.classList.remove('hidden');
                }
            }
            
            function resetApp() {
                resultsArea.classList.add('hidden');
                analyzeSection.classList.remove('hidden');
                ALL_SPORTS_DATA = []; 
                gameCardElements = [];
                gameListContainer.innerHTML = '';
                errorState.classList.add('hidden');
                evFilterToggle.checked = false;
                sortSelect.value = 'default';
                minOddsFilter.value = '';
                betSlip = [];
                slipContext = { type: 'Custom Bet Slip', settings: '' };
                renderBetSlip();
            }
            
            function updateSummaryDashboard() {
                const totalGames = ALL_SPORTS_DATA.length;
                let positiveEvOpps = 0;
                let maxEv = 0;

                gameCardElements.forEach(card => {
                    if (card.dataset.positiveEv === 'true') {
                        positiveEvOpps++;
                    }
                    maxEv = Math.max(maxEv, parseFloat(card.dataset.maxEv) || 0);
                });
                
                const impliedOdds = maxEv > 0 ? (1 / (1-maxEv)) : 'N/A';
                const americanOdds = maxEv > 0 ? (impliedOdds >= 2 ? `+${((impliedOdds - 1) * 100).toFixed(0)}` : `${(-100 / (impliedOdds - 1)).toFixed(0)}`) : 'N/A';


                summaryDashboard.innerHTML = `
                    <div class="stat-card">
                        <div class="text-sm text-secondary">Total Games</div>
                        <div class="text-2xl font-bold">${totalGames}</div>
                    </div>
                    <div class="stat-card">
                        <div class="text-sm text-secondary">+EV Opportunities</div>
                        <div class="text-2xl font-bold text-green-500">${positiveEvOpps}</div>
                    </div>
                    <div class="stat-card">
                        <div class="text-sm text-secondary">Highest EV Found</div>
                        <div class="text-2xl font-bold text-green-500">${maxEv > 0 ? `+${(maxEv * 100).toFixed(2)}%` : '0%'}</div>
                    </div>
                     <div class="stat-card">
                        <div class="text-sm text-secondary">Implied Odds</div>
                        <div class="text-2xl font-bold">${americanOdds}</div>
                    </div>
                `;
            }
            
            function displayGames(games) {
                gameListContainer.innerHTML = '';
                gameCardElements = [];
                if (games && games.length > 0) {
                    const hasSoccer = games.some(game => getGameSport(game) === 'Soccer');
                    soccerMarketControl.classList.toggle('hidden', !hasSoccer);

                    games.forEach((game, index) => {
                        const card = createGameCard(game, index);
                        gameCardElements.push(card);
                        const slider = card.querySelector('.prob-slider');
                        const awayProb = parseFloat(slider.value) / 1000;
                        calculateAndDisplayResults(card, index, awayProb);
                    });
                    resultsArea.classList.remove('hidden');
                    if (gameCardElements.length > 0 && !document.getElementById('strategy-options').hasChildNodes()) {
                        displayStrategyControls(games);
                    }
                    applyFiltersAndSorting();
                } else {
                    showError("No valid games could be displayed from the API response.");
                    resultsArea.classList.add('hidden');
                }
            }
            
            function displayStrategyControls(games) {
                const sports = [...new Set(games.map(getGameSport))].filter(s => s !== 'Unknown').sort();
                strategyOptionsContainer.innerHTML = '';
                if (sports.length > 0) {
                    sports.forEach(sport => {
                        const controlEl = document.createElement('div');
                        controlEl.className = 'flex items-center space-x-2 p-2 rounded-lg hover:bg-gray-100 dark:hover:bg-gray-800';
                        
                        let innerHTML = `
                            <input type="checkbox" id="sport-toggle-${sport}" data-sport="${sport}" class="sport-toggle-checkbox h-4 w-4 rounded text-blue-600 focus:ring-blue-500 border-gray-300" checked>
                            <label for="sport-toggle-${sport}" class="text-sm font-medium flex-1">${sport}</label>
                            <select id="strategy-${sport}" data-sport="${sport}" class="strategy-select text-sm rounded-md p-1 w-24" style="background-color: var(--input-bg); border: 1px solid var(--border-color);">
                                <option value="take">Take</option>
                                <option value="fade">Fade</option>
                                <option value="ignore">Ignore</option>
                            </select>
                        `;

                        controlEl.innerHTML = innerHTML;

                        strategyOptionsContainer.appendChild(controlEl);
                        if(sport === 'Baseball') {
                            controlEl.querySelector('select').value = 'take';
                        }
                    });
                    strategyControls.classList.remove('hidden');
                    generateParlayBtn.disabled = false;
                } else {
                    strategyControls.classList.add('hidden');
                    generateParlayBtn.disabled = true;
                }
            }

            function calculateAndDisplayResults(card, gameIndex, awayProb) {
                const game = ALL_SPORTS_DATA[gameIndex];
                if (!card || !game) return;
                const resultsContainer = card.querySelector(`#game-${gameIndex}-results`);
                resultsContainer.innerHTML = '';
                const homeProb = 1 - awayProb;
                
                let maxPositiveEv = 0;
                let hasPositiveEv = false;
                
                const createResultElement = (ev, label, odds) => {
                    if (!odds) return document.createDocumentFragment();
                    if (ev > 0) {
                        hasPositiveEv = true;
                        maxPositiveEv = Math.max(maxPositiveEv, ev);
                    }
                    const el = document.createElement('div');
                    el.className = `result-display items-center ${ev > 0 ? 'positive-ev' : 'negative-ev'}`;

                    const oddsText = odds >= 2 ? `+${((odds - 1) * 100).toFixed(0)}` : `${(-100 / (odds - 1)).toFixed(0)}`;
                    const evText = ev > 0 ? `+${(ev * 100).toFixed(2)}%` : `${(ev * 100).toFixed(2)}%`;

                    const barWidth = Math.min(Math.abs(ev) * 100 * 4, 100); 
                    let barColor;

                    if (ev > 0.10) barColor = '#16a34a';
                    else if (ev > 0.05) barColor = '#22c55e';
                    else if (ev > 0) barColor = '#4ade80';
                    else barColor = '#ef4444';

                    el.innerHTML = `
                        <div class="flex-grow">
                            <strong>${label}</strong> 
                            <span class="text-xs text-secondary">${oddsText}</span>
                        </div>
                        <div class="flex items-center flex-shrink-0">
                            <span class="font-bold w-16 text-right">${evText}</span>
                            <div class="w-12 h-1.5 ml-2 rounded-full overflow-hidden" style="background-color: var(--input-bg);">
                                <div class="h-full rounded-full" style="width: ${barWidth}%; background-color: ${barColor};"></div>
                            </div>
                        </div>
                    `;
                    el.classList.add('bet-option', 'cursor-pointer', 'transition-all', 'hover:ring-2', 'hover:ring-offset-2');
                    el.dataset.betLabel = label;
                    el.dataset.betOdds = odds;
                    el.dataset.ev = ev;

                    return el;
                };

                // Moneyline
                if (game.moneyline_away && game.moneyline_home) {
                    const awayMLEV = calculateEV(awayProb, game.moneyline_away);
                    const homeMLEV = calculateEV(homeProb, game.moneyline_home);
                    resultsContainer.appendChild(createResultElement(awayMLEV, getTeamInfo(game.away_team).name, game.moneyline_away));
                    resultsContainer.appendChild(createResultElement(homeMLEV, getTeamInfo(game.home_team).name, game.moneyline_home));
                }

                // Spread
                if (game.spread_away_odds && game.spread_home_odds) {
                    const awaySpreadEV = calculateEV(awayProb, game.spread_away_odds);
                    const homeSpreadEV = calculateEV(homeProb, game.spread_home_odds);
                    resultsContainer.appendChild(createResultElement(awaySpreadEV, `${getTeamInfo(game.away_team).name} ${game.spread_away > 0 ? '+' : ''}${game.spread_away}`, game.spread_away_odds));
                    resultsContainer.appendChild(createResultElement(homeSpreadEV, `${getTeamInfo(game.home_team).name} ${game.spread_home > 0 ? '+' : ''}${game.spread_home}`, game.spread_home_odds));
                }

                // Total
                if (game.total_over_odds && game.total_under_odds) {
                    const overTotalEV = calculateEV(awayProb, game.total_over_odds);
                    const underTotalEV = calculateEV(homeProb, game.total_under_odds);
                    resultsContainer.appendChild(createResultElement(overTotalEV, `Over ${game.total_over}`, game.total_over_odds));
                    resultsContainer.appendChild(createResultElement(underTotalEV, `Under ${game.total_under}`, game.total_under_odds));
                }

                card.dataset.maxEv = maxPositiveEv;
                card.dataset.positiveEv = hasPositiveEv;
            }

            function applyFiltersAndSorting() {
                const showPositiveOnly = evFilterToggle.checked;
                const sortBy = sortSelect.value;
                const minAmericanOdds = parseInt(minOddsFilter.value, 10);
                const minDecimalOdds = !isNaN(minAmericanOdds) ? americanToDecimal(minAmericanOdds) : null;
                let cardsToDisplay = [...gameCardElements];

                if (showPositiveOnly) {
                    cardsToDisplay = cardsToDisplay.filter(card => card.dataset.positiveEv === 'true');
                }

                if (minDecimalOdds) {
                    cardsToDisplay = cardsToDisplay.filter(card => {
                        const betOptions = card.querySelectorAll('.bet-option');
                        if (betOptions.length === 0) return true; // Don't hide cards still loading

                        // Card is visible if at least ONE of its bet options meets the odds criteria
                        return Array.from(betOptions).some(option => {
                            const betDecimalOdds = parseFloat(option.dataset.betOdds);
                            return betDecimalOdds >= minDecimalOdds;
                        });
                    });
                }

                if (sortBy === 'highest-ev') {
                    cardsToDisplay.sort((a, b) => parseFloat(b.dataset.maxEv) - parseFloat(a.dataset.maxEv));
                } else {
                    cardsToDisplay.sort((a, b) => parseInt(a.dataset.gameIndex) - parseInt(b.dataset.gameIndex));
                }
                
                gameListContainer.innerHTML = '';
                cardsToDisplay.forEach(card => gameListContainer.appendChild(card));
                
                const hasMomentumGames = ALL_SPORTS_DATA.some(game => game.spread_away != null && game.spread_home != null);
                buildMomentumParlayBtn.disabled = !hasMomentumGames;
                copyBtn.disabled = !gameCardElements.some(card => card.dataset.positiveEv === 'true');

                updateSummaryDashboard();
            }

            // --- BET SLIP & COMBO LOGIC ---

            function renderBetSlip() {
                if(betSlip.length > 0) {
                    betSlipArea.classList.remove('hidden');
                    emptySlipMessage.classList.add('hidden');
                    betSlipControls.classList.remove('hidden');
                } else {
                    // Only hide the area if it's not already hidden, to avoid flicker
                    if (!betSlipArea.classList.contains('hidden')) {
                        betSlipArea.classList.add('hidden');
                    }
                    emptySlipMessage.classList.remove('hidden');
                    betSlipControls.classList.add('hidden');
                }
                
                betSlipList.innerHTML = '';
                betSlip.forEach(bet => {
                    const betEl = document.createElement('div');
                    betEl.className = 'p-2 text-xs rounded-lg flex items-center justify-between';
                    betEl.style.backgroundColor = 'var(--accent-color-light)';
                    const game = ALL_SPORTS_DATA[bet.gameIndex];
                    const matchup = `${getTeamInfo(game.away_team).name} @ ${getTeamInfo(game.home_team).name}`;
                    const oddsText = bet.odds >= 2 ? `+${((bet.odds - 1) * 100).toFixed(0)}` : `${(-100 / (bet.odds - 1)).toFixed(0)}`;

                    betEl.innerHTML = `
                        <div class="flex-grow pr-2">
                            <p class="font-bold truncate" style="color: var(--accent-text-dark);">${bet.label}</p>
                            <p class="text-secondary truncate">${matchup}</p>
                        </div>
                        <div class="flex-shrink-0 font-bold text-center w-12" style="color: var(--accent-text-dark);">${oddsText}</div>
                         <button data-bet-id="${bet.id}" class="remove-bet-btn p-1 ml-1 rounded-full hover:bg-red-200 dark:hover:bg-red-800 flex-shrink-0">
                             <svg xmlns="http://www.w3.org/2000/svg" class="h-3 w-3 text-red-600 dark:text-red-400" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M6 18L18 6M6 6l12 12" /></svg>
                         </button>
                    `;
                    betSlipList.appendChild(betEl);
                });
                comboAnalysisBtn.disabled = betSlip.length < 2;
            }

            function handleBetClick(target) {
                slipContext = { type: 'Custom Bet Slip', settings: '' };
                const gameCard = target.closest('.game-card');
                const gameIndex = gameCard.dataset.gameIndex;
                const { betLabel, betOdds } = target.dataset;
                const betId = `${gameIndex}-${betLabel}`;

                const existingBetIndex = betSlip.findIndex(b => b.gameIndex === gameIndex);
                if (existingBetIndex > -1) {
                    const oldBet = betSlip[existingBetIndex];
                    if(oldBet.id !== betId) {
                         const oldBetEl = gameCard.querySelector(`.bet-option[data-bet-label="${CSS.escape(oldBet.label)}"]`);
                         if(oldBetEl) oldBetEl.style.borderColor = 'transparent';
                    }
                    betSlip.splice(existingBetIndex, 1);
                }

                const isAlreadySelected = target.style.borderColor !== 'transparent' && target.style.borderColor !== '';
                if (!isAlreadySelected) {
                     if (betSlip.length >= 20) {
                         console.warn("Bet slip is full. Maximum 20 bets allowed.");
                         return;
                     }
                     betSlip.push({ id: betId, gameIndex, label: betLabel, odds: parseFloat(betOdds) });
                     target.style.borderColor = 'var(--accent-color)';
                } else {
                     target.style.borderColor = 'transparent';
                }

                renderBetSlip();
            }

            function handleBuildMomentumParlay() {
                const minOddsValue = minOddsFilter.value || 'None';
                slipContext = {
                    type: 'Momentum Parlay',
                    settings: `Min Odds: ${minOddsValue}`
                };

                betSlip = [];
                gameCardElements.forEach(card => {
                    card.querySelectorAll('.bet-option').forEach(el => el.style.borderColor = 'transparent');
                });

                const minAmericanOdds = parseInt(minOddsFilter.value, 10);
                const minDecimalOdds = !isNaN(minAmericanOdds) ? americanToDecimal(minAmericanOdds) : null;
                
                const potentialBets = [];
                ALL_SPORTS_DATA.forEach((game, index) => {
                    const sport = getGameSport(game);
                    if (!game.moneyline_away || !game.moneyline_home) return;

                    const impliedAway = 1 / game.moneyline_away;
                    const impliedHome = 1 / game.moneyline_home;
                    const totalImplied = impliedAway + impliedHome;
                    const normalizedAwayProb = totalImplied > 0 ? impliedAway / totalImplied : 0.5;

                    const momentumResult = getMomentumAdjustedProbability(normalizedAwayProb, game);
                    
                    if (momentumResult.status === 'no_data') return;

                    const momentumAdjustedProb = momentumResult.prob;
                    const probabilityShift = (momentumAdjustedProb - normalizedAwayProb) * 100;

                    if (Math.abs(probabilityShift) < 0.1) return; // Ignore negligible momentum

                    let pick = {
                        gameIndex: index,
                        momentum: Math.abs(probabilityShift)
                    };

                    const highSpreadSports = ['Football', 'Basketball'];
                    const momentumTeam = probabilityShift > 0 ? 'away' : 'home';

                    if (highSpreadSports.includes(sport) && game.spread_away_odds && game.spread_home_odds) {
                        pick.label = `${getTeamInfo(game[`${momentumTeam}_team`]).name} ${game[`spread_${momentumTeam}`] > 0 ? '+' : ''}${game[`spread_${momentumTeam}`]}`;
                        pick.odds = game[`spread_${momentumTeam}_odds`];
                    } else {
                        pick.label = getTeamInfo(game[`${momentumTeam}_team`]).name;
                        pick.odds = game[`moneyline_${momentumTeam}`];
                    }
                    
                    if (!pick.odds) return; // Skip if for some reason odds are missing
                    
                    // Respect the minimum odds filter
                    if (minDecimalOdds && pick.odds < minDecimalOdds) {
                        return; 
                    }

                    pick.id = `${pick.gameIndex}-${pick.label}`;
                    potentialBets.push(pick);
                });

                potentialBets.sort((a, b) => b.momentum - a.momentum);
                const topBets = potentialBets.slice(0, 20);

                topBets.forEach(bet => {
                    betSlip.push({
                        id: bet.id,
                        gameIndex: bet.gameIndex,
                        label: bet.label,
                        odds: bet.odds
                    });
                    const card = document.getElementById(`game-${bet.gameIndex}`);
                    if (card) {
                        const betEl = card.querySelector(`.bet-option[data-bet-label="${CSS.escape(bet.label)}"]`);
                        if (betEl) betEl.style.borderColor = 'var(--accent-color)';
                    }
                });

                renderBetSlip();
            }


            function updateComboTotals() {
                const wagerPerBet = parseFloat(wagerPerBetInput.value) || 1;
                let totalBets = 0;
                let totalWager = 0;
                const checkedBoxes = comboResultsContainer.querySelectorAll('.combo-checkbox:checked');
                
                checkedBoxes.forEach(box => {
                    totalBets += parseInt(box.dataset.numBets);
                    totalWager += parseFloat(box.dataset.cost);
                });

                document.getElementById('total-bets-cell').textContent = totalBets;
                document.getElementById('total-wager-cell').textContent = `$${totalWager.toFixed(2)}`;
            }

            function calculateAndDisplayComboAnalysis() {
                const numGames = parseInt(comboTotalGamesInput.value) || betSlip.length;
                const maxComboSize = Math.min(15, numGames);
                
                if (numGames < 2) {
                    comboAvgOdds.textContent = '0.00';
                    comboResultsContainer.innerHTML = `<p class="text-center text-secondary py-4">You need at least 2 games to analyze round robins.</p>`;
                    return;
                }

                const wagerPerBet = parseFloat(wagerPerBetInput.value) || 1;
                const totalOdds = betSlip.reduce((sum, bet) => sum + bet.odds, 0);
                const calculatedAvgOdds = betSlip.length > 0 ? totalOdds / betSlip.length : 0;
                
                comboAvgOdds.textContent = decimalToAmerican(calculatedAvgOdds);

                const overrideAmericanOdds = parseFloat(comboOverrideOddsInput.value);
                const overrideDecimalOdds = americanToDecimal(overrideAmericanOdds);
                const avgOdds = !isNaN(overrideDecimalOdds) ? overrideDecimalOdds : calculatedAvgOdds;
                
                let bestProfitPerWin = -Infinity;
                let bestComboIndex = -1;
                let comboData = [];

                for (let k = 2; k <= maxComboSize; k++) {
                    const numCombos = combinations(numGames, k);
                    const costForThisComboSize = numCombos * wagerPerBet;
                    const payoutPerWinningCombo = (avgOdds ** k) * wagerPerBet;

                    let winsNeeded = -1;
                    let profitAtBreakEven = 0;
                    let profitPerWin = 0;

                    for (let w = k; w <= numGames; w++) {
                        const winningCombos = combinations(w, k);
                        const totalWinnings = winningCombos * payoutPerWinningCombo;
                        if (totalWinnings > costForThisComboSize) {
                            winsNeeded = w;
                            profitAtBreakEven = totalWinnings - costForThisComboSize;
                            if(winsNeeded > 0) {
                                profitPerWin = profitAtBreakEven / winsNeeded;
                            }
                            break;
                        }
                    }

                    if(profitPerWin > bestProfitPerWin) {
                        bestProfitPerWin = profitPerWin;
                        bestComboIndex = k;
                    }

                    comboData.push({k, numCombos, costForThisComboSize, winsNeeded, profitAtBreakEven, profitPerWin});
                }

                let resultsHtml = `
                    <table class="w-full text-sm text-left">
                        <thead class="sticky top-0 z-10" style="background-color: var(--container-bg);">
                            <tr class="border-b" style="border-color: var(--border-color);">
                                <th class="p-2 w-8"><input type="checkbox" id="select-all-combos"></th>
                                <th class="p-2 font-semibold">Combo Size</th>
                                <th class="p-2 font-semibold text-center">Cost</th>
                                <th class="p-2 font-semibold text-center">Wins for Profit</th>
                                <th class="p-2 font-semibold text-center">Profit @ B/E</th>
                                <th class="p-2 font-semibold text-center text-yellow-500">Profit / Win</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                comboData.forEach(data => {
                    const {k, numCombos, costForThisComboSize, winsNeeded, profitAtBreakEven, profitPerWin} = data;
                    const highlightClass = k === bestComboIndex ? 'best-combo-highlight' : '';

                    resultsHtml += `
                        <tr class="border-b ${highlightClass}" style="border-color: var(--border-color);">
                            <td class="p-2 text-center"><input type="checkbox" class="combo-checkbox" data-num-bets="${numCombos}" data-cost="${costForThisComboSize.toFixed(2)}"></td>
                            <td class="p-2 font-bold">${k}-Teams (${numCombos} bets)</td>
                            <td class="p-2 text-center">$${costForThisComboSize.toFixed(2)}</td>
                            <td class="p-2 text-center font-bold ${winsNeeded === -1 ? 'text-red-500' : 'text-green-500'}">
                                ${winsNeeded !== -1 ? `${winsNeeded} of ${numGames}` : 'N/A'}
                            </td>
                             <td class="p-2 text-center ${profitAtBreakEven <= 0 ? '' : 'text-green-500'}">
                                ${winsNeeded !== -1 ? `$${profitAtBreakEven.toFixed(2)}` : 'N/A'}
                            </td>
                            <td class="p-2 text-center font-semibold ${profitPerWin <= 0 ? '' : 'text-yellow-500'}">
                                ${winsNeeded !== -1 ? `$${profitPerWin.toFixed(2)}` : 'N/A'}
                            </td>
                        </tr>
                    `;
                });

                resultsHtml += `
                        </tbody>
                        <tfoot class="sticky bottom-0" style="background-color: var(--container-bg);">
                            <tr class="border-t-2" style="border-color: var(--text-primary);">
                                <td class="p-2 font-bold text-right" colspan="2">Selected Totals:</td>
                                <td id="total-wager-cell" class="p-2 font-bold text-center">$0.00</td>
                                <td class="p-2 font-bold text-center" colspan="3"><span id="total-bets-cell">0</span> Bets</td>
                            </tr>
                        </tfoot>
                    </table>`;
                comboResultsContainer.innerHTML = resultsHtml;
                updateComboTotals(); // Initial calculation
            }

            function calculateAndDisplayStrategyComboAnalysis(bets) {
                const numGames = parseInt(strategyComboTotalGamesInput.value) || bets.length;
                const maxComboSize = Math.min(15, numGames);
                
                if (numGames < 2) {
                    strategyComboAvgOdds.textContent = '0.00';
                    strategyComboResultsContainer.innerHTML = `<p class="text-center text-secondary py-4">You need at least 2 bets in the generated parlay to analyze round robins.</p>`;
                    return;
                }

                const wagerPerBet = parseFloat(strategyWagerPerBetInput.value) || 1;
                const totalOdds = bets.reduce((sum, bet) => sum + bet.odds, 0);
                const calculatedAvgOdds = bets.length > 0 ? totalOdds / bets.length : 0;

                strategyComboAvgOdds.textContent = decimalToAmerican(calculatedAvgOdds);
                
                const overrideAmericanOdds = parseFloat(strategyOverrideOddsInput.value);
                const overrideDecimalOdds = americanToDecimal(overrideAmericanOdds);
                const avgOdds = !isNaN(overrideDecimalOdds) ? overrideDecimalOdds : calculatedAvgOdds;

                let bestRoi = -Infinity;
                let bestComboIndex = -1;
                let comboData = [];

                for (let k = 2; k <= maxComboSize; k++) {
                    const numCombos = combinations(numGames, k);
                    const costForThisComboSize = numCombos * wagerPerBet;
                    const payoutPerWinningCombo = (avgOdds ** k) * wagerPerBet;

                    let winsNeeded = -1;
                    let profitAtBreakEven = 0;
                    let roiAtBreakEven = 0;

                    for (let w = k; w <= numGames; w++) {
                        const winningCombos = combinations(w, k);
                        const totalWinnings = winningCombos * payoutPerWinningCombo;
                        if (totalWinnings > costForThisComboSize) {
                            winsNeeded = w;
                            profitAtBreakEven = totalWinnings - costForThisComboSize;
                            if (costForThisComboSize > 0) {
                                roiAtBreakEven = (profitAtBreakEven / costForThisComboSize) * 100;
                            }
                            break;
                        }
                    }

                    if(roiAtBreakEven > bestRoi) {
                        bestRoi = roiAtBreakEven;
                        bestComboIndex = k;
                    }

                    comboData.push({k, numCombos, costForThisComboSize, winsNeeded, profitAtBreakEven, roiAtBreakEven});
                }


                let resultsHtml = `
                    <table class="w-full text-sm text-left">
                        <thead class="sticky top-0 z-10" style="background-color: var(--container-bg);">
                            <tr class="border-b" style="border-color: var(--border-color);">
                                <th class="p-2 w-8"><input type="checkbox" id="select-all-strategy-combos"></th>
                                <th class="p-2 font-semibold">Combo Size</th>
                                <th class="p-2 font-semibold text-center">Cost</th>
                                <th class="p-2 font-semibold text-center">Wins for Profit</th>
                                <th class="p-2 font-semibold text-center">Profit @ B/E</th>
                                <th class="p-2 font-semibold text-center text-yellow-500">ROI @ B/E</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                comboData.forEach(data => {
                    const {k, numCombos, costForThisComboSize, winsNeeded, profitAtBreakEven, roiAtBreakEven} = data;
                    const highlightClass = k === bestComboIndex ? 'best-combo-highlight' : '';

                    resultsHtml += `
                        <tr class="border-b ${highlightClass}" style="border-color: var(--border-color);">
                            <td class="p-2 text-center"><input type="checkbox" class="strategy-combo-checkbox" data-num-bets="${numCombos}" data-cost="${costForThisComboSize.toFixed(2)}"></td>
                            <td class="p-2 font-bold">${k}-Teams (${numCombos} bets)</td>
                            <td class="p-2 text-center">$${costForThisComboSize.toFixed(2)}</td>
                            <td class="p-2 text-center font-bold ${winsNeeded === -1 ? 'text-red-500' : 'text-green-500'}">
                                ${winsNeeded !== -1 ? `${winsNeeded} of ${numGames}` : 'N/A'}
                            </td>
                             <td class="p-2 text-center ${profitAtBreakEven <= 0 ? '' : 'text-green-500'}">
                                ${winsNeeded !== -1 ? `$${profitAtBreakEven.toFixed(2)}` : 'N/A'}
                            </td>
                            <td class="p-2 text-center font-semibold ${roiAtBreakEven <= 0 ? '' : 'text-yellow-500'}">
                                ${winsNeeded !== -1 ? `+${roiAtBreakEven.toFixed(0)}%` : 'N/A'}
                            </td>
                        </tr>
                    `;
                });

                resultsHtml += `
                        </tbody>
                        <tfoot class="sticky bottom-0" style="background-color: var(--container-bg);">
                            <tr class="border-t-2" style="border-color: var(--text-primary);">
                                <td class="p-2 font-bold text-right" colspan="2">Selected Totals:</td>
                                <td id="total-strategy-wager-cell" class="p-2 font-bold text-center">$0.00</td>
                                <td class="p-2 font-bold text-center" colspan="3"><span id="total-strategy-bets-cell">0</span> Bets</td>
                            </tr>
                        </tfoot>
                    </table>`;
                strategyComboResultsContainer.innerHTML = resultsHtml;
                updateStrategyComboTotals();
            }
            
            function updateStrategyComboTotals() {
                const wagerPerBet = parseFloat(strategyWagerPerBetInput.value) || 1;
                let totalBets = 0;
                let totalWager = 0;
                const checkedBoxes = strategyComboResultsContainer.querySelectorAll('.strategy-combo-checkbox:checked');
                
                checkedBoxes.forEach(box => {
                    totalBets += parseInt(box.dataset.numBets);
                    totalWager += parseFloat(box.dataset.cost);
                });

                document.getElementById('total-strategy-bets-cell').textContent = totalBets;
                document.getElementById('total-strategy-wager-cell').textContent = `$${totalWager.toFixed(2)}`;
            }

            // --- EVENT HANDLERS ---
            function updateCardFromSlider(gameIndex, sliderValue) {
                const awayProbPercent = sliderValue / 10;
                const awayInput = document.getElementById(`game-${gameIndex}-away-prob-input`);
                const homeInput = document.getElementById(`game-${gameIndex}-home-prob-input`);
                
                if(document.activeElement !== awayInput) awayInput.value = awayProbPercent.toFixed(1);
                if(document.activeElement !== homeInput) homeInput.value = (100 - awayProbPercent).toFixed(1);
                
                const card = document.getElementById(`game-${gameIndex}`);
                if (card) {
                    calculateAndDisplayResults(card, gameIndex, awayProbPercent / 100);
                }
                applyFiltersAndSorting();
            }

            function updateCardFromInput(gameIndex, changedInput, otherInput) {
                let value = parseFloat(changedInput.value);
                if (isNaN(value) || value < 0) value = 0;
                if (value > 100) value = 100;

                const slider = document.querySelector(`.prob-slider[data-game-index="${gameIndex}"]`);
                if (changedInput.id.includes('away')) {
                    slider.value = value * 10;
                    otherInput.value = (100 - value).toFixed(1);
                } else { // home changed
                    slider.value = (100 - value) * 10;
                    otherInput.value = (100 - value).toFixed(1);
                }

                const card = document.getElementById(`game-${gameIndex}`);
                if(card) {
                    calculateAndDisplayResults(card, gameIndex, parseFloat(slider.value) / 1000);
                }
                applyFiltersAndSorting();
            }
            
            function handleResetProbability(e) {
                const gameIndex = e.dataset.gameIndex;
                const slider = document.querySelector(`.prob-slider[data-game-index="${gameIndex}"]`);
                if (slider) {
                    slider.value = slider.dataset.initialValue;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
            function handle50PercentClick(e) {
                 const gameIndex = e.dataset.gameIndex;
                const slider = document.querySelector(`.prob-slider[data-game-index="${gameIndex}"]`);
                if (slider) {
                    slider.value = 500;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                }
            }
            function handleCopyClick() {
                const minOddsValue = minOddsFilter.value || 'None';
                let textToCopy = `Audit the Odds - Filtered +EV Bets\n`;
                textToCopy += `Settings: Min Odds: ${minOddsValue}\n\n`;

                const visibleCards = gameListContainer.querySelectorAll('.game-card');
                visibleCards.forEach((card) => {
                     if (card.dataset.positiveEv === 'true') {
                        const gameIndex = card.dataset.gameIndex;
                        const game = ALL_SPORTS_DATA[gameIndex];
                        const awayTeamInfo = getTeamInfo(game.away_team);
                        const homeTeamInfo = getTeamInfo(game.home_team);
                        textToCopy += `------------------------------\n${awayTeamInfo.name} vs. ${homeTeamInfo.name}\n`;
                        card.querySelectorAll('.positive-ev').forEach(resultEl => {
                            const winnerName = resultEl.querySelector('strong').textContent;
                            const evText = resultEl.querySelector('span.font-bold').textContent;
                            
                            let probabilityText = '';
                            if(winnerName.includes(awayTeamInfo.name)) {
                                probabilityText = document.getElementById(`game-${gameIndex}-away-prob-input`).value;
                            } else if (winnerName.includes(homeTeamInfo.name)) {
                                 probabilityText = document.getElementById(`game-${gameIndex}-home-prob-input`).value;
                            } else {
                                 const sliderVal = document.querySelector(`.prob-slider[data-game-index="${gameIndex}"]`).value;
                                 probabilityText = `${(sliderVal/10).toFixed(1)}%`;
                            }
                            textToCopy += `WINNER: ${winnerName} (EV: ${evText}) | Your Prob: ${probabilityText}%\n`;
                        });
                        textToCopy += "\n";
                       }
                });
                copyToClipboard(textToCopy, copyBtnText, 'Copy +EV Games');
            }

            function handleGenerateParlayClick() {
                const minOddsValue = minOddsFilter.value || 'None';
                const sportSettings = [];
                document.querySelectorAll('.sport-toggle-checkbox:checked').forEach(checkbox => {
                    const sport = checkbox.dataset.sport;
                    const strategy = document.getElementById(`strategy-${sport}`).value;
                    sportSettings.push(`${sport}: ${strategy.charAt(0).toUpperCase() + strategy.slice(1)}`);
                });

                slipContext = {
                    type: 'Strategy Parlay',
                    settings: `Min Odds: ${minOddsValue} | ${sportSettings.join(', ')}`
                };

                const strategies = {};
                document.querySelectorAll('.strategy-select').forEach(select => {
                    strategies[select.dataset.sport] = select.value;
                });

                const selectedSports = new Set();
                document.querySelectorAll('.sport-toggle-checkbox:checked').forEach(checkbox => {
                    selectedSports.add(checkbox.dataset.sport);
                });

                const minAmericanOdds = parseInt(minOddsFilter.value, 10);
                const minDecimalOdds = !isNaN(minAmericanOdds) ? americanToDecimal(minAmericanOdds) : null;

                let generatedBets = [];
                const usedGameIndices = new Set();
                
                const availableGames = ALL_SPORTS_DATA
                    .map((game, index) => ({ ...game, originalIndex: index }))
                    .filter(game => selectedSports.has(getGameSport(game)));

                availableGames.forEach((game) => {
                    const sport = getGameSport(game);
                    const strategy = strategies[sport];
                    if (strategy === 'ignore' || !game.moneyline_away || !game.moneyline_home) return;

                    const awayEV = calculateEV(0.5, game.moneyline_away);
                    const homeEV = calculateEV(0.5, game.moneyline_home);

                    if (awayEV <= 0 && homeEV <= 0) return;

                    const predictedWinner = awayEV > homeEV ? 'away' : 'home';
                    const finalPickTeam = (strategy === 'take') ? predictedWinner : (predictedWinner === 'away' ? 'home' : 'away');
                    
                    let betToAdd = null;
                    const isSpreadSport = ['Football', 'Basketball'].includes(sport);
                    const canUseSpread = game.spread_away_odds && game.spread_home_odds;

                    if (sport === 'Soccer') {
                        const soccerDefaultOdds = americanToDecimal(-111); // Approx 1.90
                        betToAdd = {
                            odds: soccerDefaultOdds,
                            label: `${getTeamInfo(game[`${finalPickTeam}_team`]).name} (Spread)`,
                            ev: calculateEV(0.5, soccerDefaultOdds),
                            gameIndex: game.originalIndex
                        };
                    } else if (isSpreadSport && canUseSpread) {
                         betToAdd = {
                            odds: game[`spread_${finalPickTeam}_odds`],
                            label: `${getTeamInfo(game[`${finalPickTeam}_team`]).name} ${game[`spread_${finalPickTeam}`] > 0 ? '+' : ''}${game[`spread_${finalPickTeam}`]}`,
                            ev: calculateEV(0.5, game[`spread_${finalPickTeam}_odds`]),
                            gameIndex: game.originalIndex
                        };
                    } else { // Default to moneyline for MLB, NHL, and as a fallback if spread isn't available
                         betToAdd = {
                            odds: game[`moneyline_${finalPickTeam}`],
                            label: `${getTeamInfo(game[`${finalPickTeam}_team`]).name} (ML)`,
                            ev: calculateEV(0.5, game[`moneyline_${finalPickTeam}`]),
                            gameIndex: game.originalIndex
                        };
                    }

                    if (betToAdd && (!minDecimalOdds || betToAdd.odds >= minDecimalOdds)) {
                        generatedBets.push(betToAdd);
                        usedGameIndices.add(game.originalIndex);
                    }
                });

                const PARLAY_CAP = 20;
                const slotsToFill = PARLAY_CAP - generatedBets.length;
                if (slotsToFill > 0) {
                    const fillerPicks = [];
                    const fillerCandidates = availableGames.filter(game => !usedGameIndices.has(game.originalIndex));

                    fillerCandidates.forEach((game) => {
                        if (!game.total_over_odds || !game.total_under_odds) return;
                        const overEV = calculateEV(0.5, game.total_over_odds);
                        const underEV = calculateEV(0.5, game.total_under_odds);

                        if (overEV > underEV) {
                            const pick = { ev: overEV, odds: game.total_over_odds, label: `Over ${game.total_over}`, gameIndex: game.originalIndex };
                            if (!minDecimalOdds || pick.odds >= minDecimalOdds) {
                                fillerPicks.push(pick);
                            }
                        } else {
                            const pick = { ev: underEV, odds: game.total_under_odds, label: `Under ${game.total_under}`, gameIndex: game.originalIndex };
                            if (!minDecimalOdds || pick.odds >= minDecimalOdds) {
                                fillerPicks.push(pick);
                            }
                        }
                    });

                    fillerPicks.sort((a, b) => b.ev - a.ev);
                    generatedBets.push(...fillerPicks.slice(0, slotsToFill));
                }

                generatedBets.sort((a,b) => b.ev - a.ev);
                currentStrategyBets = generatedBets.slice(0, PARLAY_CAP);

                if (currentStrategyBets.length === 0) {
                    parlayBtnText.textContent = 'No Picks Found';
                    setTimeout(() => { parlayBtnText.textContent = 'Analyze Parlay Strategy'; }, 2500);
                    return;
                }
                
                strategyComboTotalGamesInput.value = currentStrategyBets.length;
                showStrategyComboAnalysis();
            }

            function showStrategyComboAnalysis() {
                strategyComboModal.classList.remove('hidden');
                setTimeout(() => { 
                    strategyComboModal.classList.remove('opacity-0');
                    strategyComboModalContent.classList.remove('scale-95');
                    calculateAndDisplayStrategyComboAnalysis(currentStrategyBets);
                }, 10);
            }

            function hideStrategyComboModal() {
                strategyComboModal.classList.add('opacity-0');
                strategyComboModalContent.classList.add('scale-95');
                setTimeout(() => strategyComboModal.classList.add('hidden'), 300);
            }
            
            function handleCopyStrategyParlay() {
                if (currentStrategyBets.length > 0) {
                    const title = `${slipContext.type} (${currentStrategyBets.length} Picks)`;

                    const colors = {
                        containerBg: '#f1f5f9', accent: '#2563eb', textPrimary: '#0f172a', textSecondary: '#475569', border: '#e2e8f0'
                    };
                    let htmlToCopy = `<div style="font-family: Inter, sans-serif; color: ${colors.textPrimary};">`;
                    htmlToCopy += `<h3 style="font-size: 18px; font-weight: 700; margin-bottom: 4px;">${title}</h3>`;
                    htmlToCopy += `<p style="font-size: 12px; color: ${colors.textSecondary}; margin-bottom: 12px; border-bottom: 1px solid ${colors.border}; padding-bottom: 8px;">Settings: ${slipContext.settings}</p>`;

                    currentStrategyBets.forEach(bet => {
                        const oddsText = bet.odds >= 2 ? `+${((bet.odds - 1) * 100).toFixed(0)}` : `${(-100 / (bet.odds - 1)).toFixed(0)}`;
                        
                        let subtext = '';
                        if ((bet.label.toLowerCase().startsWith('over') || bet.label.toLowerCase().startsWith('under')) && bet.gameIndex !== undefined) {
                            const game = ALL_SPORTS_DATA[bet.gameIndex];
                            if (game) {
                                const matchup = `${getTeamInfo(game.away_team).name} @ ${getTeamInfo(game.home_team).name}`;
                                subtext = `<p style="margin: 0; font-size: 12px; color: ${colors.textSecondary};">${matchup}</p>`;
                            }
                        }

                        htmlToCopy += `
                            <div style="background-color: ${colors.containerBg}; border-radius: 8px; padding: 12px; font-size: 14px; margin-bottom: 8px; border: 1px solid ${colors.border};">
                                <p style="font-weight: 600; margin: 0 0 4px 0; color: ${colors.textPrimary};">${bet.label} <span style="font-weight: 700; color: ${colors.accent};">(${oddsText})</span></p>
                                ${subtext}
                            </div>
                        `;
                    });
                    htmlToCopy += `</div>`;
                    copyHtmlToClipboard(htmlToCopy, copyStrategyParlayBtnText, 'Copy Parlay & Close');
                }
                 setTimeout(hideStrategyComboModal, 500);
            }

            function copyToClipboard(text, buttonTextElement, originalText) {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    buttonTextElement.textContent = 'Copied!';
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    buttonTextElement.textContent = 'Copy Failed';
                }
                document.body.removeChild(textArea);
                setTimeout(() => { buttonTextElement.textContent = originalText; }, 2000);
            }

            function copyHtmlToClipboard(html, buttonTextElement, originalText) {
                const tempEl = document.createElement('div');
                tempEl.style.position = 'absolute';
                tempEl.style.left = '-9999px';
                tempEl.innerHTML = html;
                document.body.appendChild(tempEl);

                const range = document.createRange();
                range.selectNodeContents(tempEl);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);

                try {
                    document.execCommand('copy');
                    buttonTextElement.textContent = 'Copied!';
                } catch (err) {
                    console.error('Failed to copy HTML: ', err);
                    buttonTextElement.textContent = 'Copy Failed';
                }

                selection.removeAllRanges();
                document.body.removeChild(tempEl);
                setTimeout(() => { buttonTextElement.textContent = originalText; }, 2000);
            }

            function attachEventListeners() {
                gameListContainer.addEventListener('input', e => {
                    if (e.target.classList.contains('prob-slider')) {
                        updateCardFromSlider(e.target.dataset.gameIndex, parseFloat(e.target.value));
                    }
                });
                gameListContainer.addEventListener('change', e => {
                    if (e.target.classList.contains('prob-input')) {
                        const gameIndex = e.target.closest('.game-card').dataset.gameIndex;
                        const awayInput = document.getElementById(`game-${gameIndex}-away-prob-input`);
                        const homeInput = document.getElementById(`game-${gameIndex}-home-prob-input`);
                        if (e.target.id === awayInput.id) {
                            updateCardFromInput(gameIndex, awayInput, homeInput);
                        } else {
                            updateCardFromInput(gameIndex, homeInput, awayInput);
                        }
                    }
                });

                gameListContainer.addEventListener('click', e => {
                    if (e.target.closest('.reset-prob-btn')) { handleResetProbability(e.target.closest('.reset-prob-btn')); }
                    if (e.target.closest('.fifty-fifty-btn')) { handle50PercentClick(e.target.closest('.fifty-fifty-btn')); }
                    const betOption = e.target.closest('.bet-option');
                    if (betOption) {
                        handleBetClick(betOption);
                    }
                });
            }

            // --- SETUP LISTENERS ---
            evFilterToggle.addEventListener('change', applyFiltersAndSorting);
            sortSelect.addEventListener('change', applyFiltersAndSorting);
            minOddsFilter.addEventListener('input', applyFiltersAndSorting);
            soccerMarketSelect.addEventListener('change', () => displayGames(ALL_SPORTS_DATA));
            copyBtn.addEventListener('click', handleCopyClick);
            buildMomentumParlayBtn.addEventListener('click', handleBuildMomentumParlay);
            generateParlayBtn.addEventListener('click', handleGenerateParlayClick);
            analyzeTodayBtn.addEventListener('click', fetchAndAnalyzeGames);
            newAnalysisBtn.addEventListener('click', resetApp);
            helpBtn.addEventListener('click', () => {
                helpModal.classList.remove('hidden');
                setTimeout(() => { 
                    helpModal.classList.remove('opacity-0');
                    helpModalContent.classList.remove('scale-95');
                }, 10);
            });
            closeHelpModalBtn.addEventListener('click', () => {
                helpModal.classList.add('opacity-0');
                helpModalContent.classList.add('scale-95');
                setTimeout(() => helpModal.classList.add('hidden'), 300);
            });
            
             // Bet Slip Listeners
            clearSlipBtn.addEventListener('click', () => {
                betSlip = [];
                slipContext = { type: 'Custom Bet Slip', settings: '' };
                gameCardElements.forEach(card => {
                    card.querySelectorAll('.bet-option').forEach(el => el.style.borderColor = 'transparent');
                });
                renderBetSlip();
            });

            betSlipList.addEventListener('click', (e) => {
                const removeBtn = e.target.closest('.remove-bet-btn');
                if (removeBtn) {
                    slipContext = { type: 'Custom Bet Slip', settings: '' };
                    const betIdToRemove = removeBtn.dataset.betId;
                    const betIndex = betSlip.findIndex(b => b.id === betIdToRemove);
                    if(betIndex > -1) {
                        const betToRemove = betSlip[betIndex];
                        const gameCard = document.getElementById(`game-${betToRemove.gameIndex}`);
                        if(gameCard){
                             const betEl = gameCard.querySelector(`.bet-option[data-bet-label="${CSS.escape(betToRemove.label)}"]`);
                             if(betEl) betEl.style.borderColor = 'transparent';
                        }
                        betSlip.splice(betIndex, 1);
                        renderBetSlip();
                    }
                }
            });

             copySlipBtn.addEventListener('click', () => {
                if (betSlip.length > 0) {
                    const minOddsValue = minOddsFilter.value || 'None';
                    if (slipContext.type === 'Custom Bet Slip') {
                        slipContext.settings = `Min Odds: ${minOddsValue}`;
                    }
                    const colors = {
                        containerBg: '#f1f5f9', accent: '#2563eb', textPrimary: '#0f172a', textSecondary: '#475569', border: '#e2e8f0'
                    };
                    let htmlToCopy = `<div style="font-family: Inter, sans-serif; color: ${colors.textPrimary};">`;
                    htmlToCopy += `<h3 style="font-size: 18px; font-weight: 700; margin-bottom: 4px;">${slipContext.type} (${betSlip.length} Picks)</h3>`;
                    htmlToCopy += `<p style="font-size: 12px; color: ${colors.textSecondary}; margin-bottom: 12px; border-bottom: 1px solid ${colors.border}; padding-bottom: 8px;">Settings: ${slipContext.settings}</p>`;
                    
                    betSlip.forEach(bet => {
                        const game = ALL_SPORTS_DATA[bet.gameIndex];
                        const matchup = `${getTeamInfo(game.away_team).name} @ ${getTeamInfo(game.home_team).name}`;
                         const oddsText = bet.odds >= 2 ? `+${((bet.odds - 1) * 100).toFixed(0)}` : `${(-100 / (bet.odds - 1)).toFixed(0)}`;
                        htmlToCopy += `
                            <div style="background-color: ${colors.containerBg}; border-radius: 8px; padding: 12px; font-size: 14px; margin-bottom: 8px; border: 1px solid ${colors.border};">
                                <p style="font-weight: 600; margin: 0 0 4px 0; color: ${colors.textPrimary};">${bet.label} <span style="font-weight: 700; color: ${colors.accent};">(${oddsText})</span></p>
                                <p style="margin: 0; font-size: 12px; color: ${colors.textSecondary};">${matchup}</p>
                            </div>
                        `;
                    });
                    htmlToCopy += `</div>`;
                    copyHtmlToClipboard(htmlToCopy, copySlipBtnText, 'Copy Slip');
                }
            });
            
            // Bet Slip Combo Modal Listeners
            comboAnalysisBtn.addEventListener('click', () => {
                if (betSlip.length >= 2) {
                    comboTotalGamesInput.value = betSlip.length;
                    comboModal.classList.remove('hidden');
                    setTimeout(() => {
                        comboModal.classList.remove('opacity-0');
                        comboModalContent.classList.remove('scale-95');
                        calculateAndDisplayComboAnalysis();
                    }, 10);
                }
            });
            const hideComboModal = () => {
                 comboModal.classList.add('opacity-0');
                 comboModalContent.classList.add('scale-95');
                 setTimeout(() => comboModal.classList.add('hidden'), 300);
            };
            closeComboModalBtn.addEventListener('click', hideComboModal);
            wagerPerBetInput.addEventListener('input', calculateAndDisplayComboAnalysis);
            comboTotalGamesInput.addEventListener('input', calculateAndDisplayComboAnalysis);
            comboOverrideOddsInput.addEventListener('input', calculateAndDisplayComboAnalysis);
            
            comboResultsContainer.addEventListener('change', (e) => {
                if (e.target.matches('#select-all-combos')) {
                    comboResultsContainer.querySelectorAll('.combo-checkbox').forEach(box => {
                        box.checked = e.target.checked;
                    });
                }
                updateComboTotals();
            });
            
            // Strategy Controls Listeners
            document.getElementById('select-all-sports').addEventListener('click', () => {
                document.querySelectorAll('.sport-toggle-checkbox').forEach(box => box.checked = true);
            });
            document.getElementById('deselect-all-sports').addEventListener('click', () => {
                document.querySelectorAll('.sport-toggle-checkbox').forEach(box => box.checked = false);
            });

            // Strategy Combo Modal Listeners
            closeStrategyComboModalBtn.addEventListener('click', hideStrategyComboModal);
            strategyWagerPerBetInput.addEventListener('input', () => calculateAndDisplayStrategyComboAnalysis(currentStrategyBets));
            strategyComboTotalGamesInput.addEventListener('input', () => calculateAndDisplayStrategyComboAnalysis(currentStrategyBets));
            strategyOverrideOddsInput.addEventListener('input', () => calculateAndDisplayStrategyComboAnalysis(currentStrategyBets));
            copyStrategyParlayBtn.addEventListener('click', handleCopyStrategyParlay);

            strategyComboResultsContainer.addEventListener('change', (e) => {
                if (e.target.matches('#select-all-strategy-combos')) {
                    strategyComboResultsContainer.querySelectorAll('.strategy-combo-checkbox').forEach(box => {
                        box.checked = e.target.checked;
                    });
                }
                updateStrategyComboTotals();
            });

             // Attaching all one-time listeners
            attachEventListeners();

        });
    </script>
</body>
</html>

